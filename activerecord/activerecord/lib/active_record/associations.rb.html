<!DOCTYPE html>
<html>
  <head>
    <base href="../../.."/>
    <script src="assets/jquery-3.2.1.min.js"></script>
    <script src="https://use.fontawesome.com/81e98abb93.js"></script>
    <link rel="stylesheet" href="assets/deep_cover.css" type="text/css"/>
  </head>
  <body class="source">
    <div class="overlay">
      <div class="center">
        <div class="stats"><table><tr><th class="node">Nodes</th><th class="per_char">Chars</th><th class="branch">Branches</th></tr><tr><td class="node"><span class="executed" title="executed">696</span>  / <span class="potentially_executable" title="potentially_executable">813</span></td><td class="per_char"><span class="executed" title="executed">8166</span>  / <span class="potentially_executable" title="potentially_executable">9397</span></td><td class="branch"><span class="executed" title="executed">29</span>  / <span class="potentially_executable" title="potentially_executable">33</span></td></tr></table></div>
      </div>
    </div>
    <header>
      <div class="content">
        <div class="info"><span class="deep-cover"><span class="deep">Deep</span>Cover</span>
          <span class="version">v0.1.16</span>
        </div>
        <div class="nav">
          <a href="index.html" aria-label="Home"><i class="fa fa-home" aria-hidden="true"></i></a>
          <span class="path">activerecord/lib/active_record/associations.rb<span>
        </div>
      </div>
    </header>
    <main class="source"><table class="source"><tr><td id="L1" class="nb">1</td><td># frozen_string_literal: true</td></tr><tr><td id="L2" class="nb">2</td><td></td></tr><tr><td id="L3" class="nb">3</td><td><span class="node-send kind-selector_begin run" title="11x">require</span> <span class="node-str kind-expression run" title="11x">"active_support/core_ext/enumerable"</span></td></tr><tr><td id="L4" class="nb">4</td><td><span class="node-send kind-selector_begin run" title="11x">require</span> <span class="node-str kind-expression run" title="11x">"active_support/core_ext/string/conversions"</span></td></tr><tr><td id="L5" class="nb">5</td><td><span class="node-send kind-selector_begin run" title="11x">require</span> <span class="node-str kind-expression run" title="11x">"active_support/core_ext/module/remove_method"</span></td></tr><tr><td id="L6" class="nb">6</td><td><span class="node-send kind-selector_begin run" title="11x">require</span> <span class="node-str kind-expression run" title="11x">"active_record/errors"</span></td></tr><tr><td id="L7" class="nb">7</td><td></td></tr><tr><td id="L8" class="nb">8</td><td><span class="node-module kind-keyword run" title="11x">module</span> <span class="node-const kind-name run" title="11x">ActiveRecord</span></td></tr><tr><td id="L9" class="nb">9</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">AssociationNotFoundError</span> &lt; <span class="node-const kind-name run" title="11x">ConfigurationError</span> #:nodoc:</td></tr><tr><td id="L10" class="nb">10</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(record = <span class="node-nil kind-expression run" title="8x">nil</span>, association_name = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L11" class="nb">11</td><td>      <span class="fork fork-whole fork-run " data-fork-id="0"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="48x"></i><span class="node-if kind-keyword run" title="48x">if</span> <span class="fork fork-whole fork-run " data-fork-id="1"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="48x"></i><span class="node-lvar kind-name run" title="48x">record</span> <span class="node-and kind-operator run" title="48x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="1"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="40x"></i><span class="node-lvar kind-name run" title="40x">association_name</span></span></span></span></td></tr><tr><td id="L12" class="nb">12</td><td>        <span class="fork fork-branch fork-run " data-fork-id="0"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="40x"></i><span class="node-super kind-keyword run" title="40x">super</span><span class="node-super kind-begin run" title="40x">(</span><span class="node-dstr kind-begin run" title="40x">"</span><span class="node-str kind-expression run" title="40x">Association named '</span><span class="node-begin kind-begin run" title="40x">#{</span><span class="node-lvar kind-name run" title="40x">association_name</span><span class="node-begin kind-end run" title="40x">}</span><span class="node-str kind-expression run" title="40x">' was not found on </span><span class="node-begin kind-begin run" title="40x">#{</span><span class="node-lvar kind-name run" title="40x">record</span><span class="node-send kind-dot run" title="40x">.</span><span class="node-send kind-selector_begin run" title="40x">class</span><span class="node-send kind-dot run" title="40x">.</span><span class="node-send kind-selector_begin run" title="40x">name</span><span class="node-begin kind-end run" title="40x">}</span><span class="node-str kind-expression run" title="40x">; perhaps you misspelled it?</span><span class="node-dstr kind-end run" title="40x">"</span><span class="node-super kind-end run" title="40x">)</span></span></td></tr><tr><td id="L13" class="nb">13</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L14" class="nb">14</td><td>        <span class="fork fork-branch fork-run " data-fork-id="0"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Association was not found."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L15" class="nb">15</td><td>      end</td></tr><tr><td id="L16" class="nb">16</td><td>    end</td></tr><tr><td id="L17" class="nb">17</td><td>  end</td></tr><tr><td id="L18" class="nb">18</td><td></td></tr><tr><td id="L19" class="nb">19</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">InverseOfAssociationNotFoundError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L20" class="nb">20</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(reflection = <span class="node-nil kind-expression run" title="8x">nil</span>, associated_class = <span class="node-nil kind-expression run" title="33x">nil</span>)</td></tr><tr><td id="L21" class="nb">21</td><td>      <span class="fork fork-whole fork-run " data-fork-id="2"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="45x"></i><span class="node-if kind-keyword run" title="45x">if</span> <span class="node-lvar kind-name run" title="45x">reflection</span></span></td></tr><tr><td id="L22" class="nb">22</td><td>        <span class="fork fork-branch fork-run " data-fork-id="2"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="37x"></i><span class="node-super kind-keyword run" title="37x">super</span><span class="node-super kind-begin run" title="37x">(</span><span class="node-dstr kind-begin run" title="37x">"</span><span class="node-str kind-expression run" title="37x">Could not find the inverse association for </span><span class="node-begin kind-begin run" title="37x">#{</span><span class="node-lvar kind-name run" title="37x">reflection</span><span class="node-send kind-dot run" title="37x">.</span><span class="node-send kind-selector_begin run" title="37x">name</span><span class="node-begin kind-end run" title="37x">}</span><span class="node-str kind-expression run" title="37x"> (</span><span class="node-begin kind-begin run" title="37x">#{</span><span class="node-lvar kind-name run" title="37x">reflection</span><span class="node-send kind-dot run" title="37x">.</span><span class="node-send kind-selector_begin run" title="37x">options</span><span class="node-send kind-selector_begin run" title="37x">[</span><span class="node-sym kind-expression run" title="37x">:inverse_of</span><span class="node-send kind-selector_end run" title="37x">]</span><span class="node-send kind-dot run" title="37x">.</span><span class="node-send kind-selector_begin run" title="37x">inspect</span><span class="node-begin kind-end run" title="37x">}</span><span class="node-str kind-expression run" title="37x"> in </span><span class="node-begin kind-begin run" title="37x">#{</span><span class="fork fork-whole fork-run " data-fork-id="3"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="37x"></i><span class="node-lvar kind-name run" title="37x">associated_class</span><span class="node-send kind-dot run" title="37x">.</span><span class="node-send kind-selector_begin run" title="37x">nil?</span> <span class="node-if kind-question run" title="37x">?</span> <span class="fork fork-branch fork-run " data-fork-id="3"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="25x"></i><span class="node-lvar kind-name run" title="25x">reflection</span><span class="node-send kind-dot run" title="25x">.</span><span class="node-send kind-selector_begin run" title="25x">class_name</span></span> <span class="node-send kind-colon run" title="12x">:</span> <span class="fork fork-branch fork-run " data-fork-id="3"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="12x"></i><span class="node-lvar kind-name run" title="12x">associated_class</span><span class="node-send kind-dot run" title="12x">.</span><span class="node-send kind-selector_begin run" title="12x">name</span></span></span><span class="node-begin kind-end run" title="37x">}</span><span class="node-str kind-expression run" title="37x">)</span><span class="node-dstr kind-end run" title="37x">"</span><span class="node-super kind-end run" title="37x">)</span></span></td></tr><tr><td id="L23" class="nb">23</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L24" class="nb">24</td><td>        <span class="fork fork-branch fork-run " data-fork-id="2"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Could not find the inverse association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L25" class="nb">25</td><td>      end</td></tr><tr><td id="L26" class="nb">26</td><td>    end</td></tr><tr><td id="L27" class="nb">27</td><td>  end</td></tr><tr><td id="L28" class="nb">28</td><td></td></tr><tr><td id="L29" class="nb">29</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughAssociationNotFoundError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L30" class="nb">30</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L31" class="nb">31</td><td>      <span class="fork fork-whole fork-run " data-fork-id="4"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-if kind-keyword run" title="13x">if</span> <span class="fork fork-whole fork-run " data-fork-id="5"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-lvar kind-name run" title="13x">owner_class_name</span> <span class="node-and kind-operator run" title="13x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="5"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-lvar kind-name run" title="5x">reflection</span></span></span></span></td></tr><tr><td id="L32" class="nb">32</td><td>        <span class="fork fork-branch fork-run " data-fork-id="4"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-super kind-keyword run" title="5x">super</span><span class="node-super kind-begin run" title="5x">(</span><span class="node-dstr kind-begin run" title="5x">"</span><span class="node-str kind-expression run" title="5x">Could not find the association </span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">options</span><span class="node-send kind-selector_begin run" title="5x">[</span><span class="node-sym kind-expression run" title="5x">:through</span><span class="node-send kind-selector_end run" title="5x">]</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">inspect</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x"> in model </span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">owner_class_name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-dstr kind-end run" title="5x">"</span><span class="node-super kind-end run" title="5x">)</span></span></td></tr><tr><td id="L33" class="nb">33</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L34" class="nb">34</td><td>        <span class="fork fork-branch fork-run " data-fork-id="4"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Could not find the association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L35" class="nb">35</td><td>      end</td></tr><tr><td id="L36" class="nb">36</td><td>    end</td></tr><tr><td id="L37" class="nb">37</td><td>  end</td></tr><tr><td id="L38" class="nb">38</td><td></td></tr><tr><td id="L39" class="nb">39</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughAssociationPolymorphicSourceError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L40" class="nb">40</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>, source_reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L41" class="nb">41</td><td>      <span class="fork fork-whole fork-run " data-fork-id="6"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-if kind-keyword run" title="13x">if</span> <span class="fork fork-whole fork-run " data-fork-id="7"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="fork fork-whole fork-run " data-fork-id="8"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-lvar kind-name run" title="13x">owner_class_name</span> <span class="node-and kind-operator run" title="13x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="8"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-lvar kind-name run" title="5x">reflection</span></span></span> <span class="node-and kind-operator run" title="13x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="7"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-lvar kind-name run" title="5x">source_reflection</span></span></span></span></td></tr><tr><td id="L42" class="nb">42</td><td>        <span class="fork fork-branch fork-run " data-fork-id="6"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-super kind-keyword run" title="5x">super</span><span class="node-super kind-begin run" title="5x">(</span><span class="node-dstr kind-begin run" title="5x">"</span><span class="node-str kind-expression run" title="5x">Cannot have a has_many :through association '</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">owner_class_name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">#</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">' on the polymorphic object '</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">source_reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">class_name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">#</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">source_reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">' without 'source_type'. Try adding 'source_type: \"</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">name</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">to_s</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">classify</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">\"' to 'has_many :through' definition.</span><span class="node-dstr kind-end run" title="5x">"</span><span class="node-super kind-end run" title="5x">)</span></span></td></tr><tr><td id="L43" class="nb">43</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L44" class="nb">44</td><td>        <span class="fork fork-branch fork-run " data-fork-id="6"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Cannot have a has_many :through association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L45" class="nb">45</td><td>      end</td></tr><tr><td id="L46" class="nb">46</td><td>    end</td></tr><tr><td id="L47" class="nb">47</td><td>  end</td></tr><tr><td id="L48" class="nb">48</td><td></td></tr><tr><td id="L49" class="nb">49</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughAssociationPolymorphicThroughError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L50" class="nb">50</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L51" class="nb">51</td><td>      <span class="fork fork-whole fork-run " data-fork-id="9"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-if kind-keyword run" title="13x">if</span> <span class="fork fork-whole fork-run " data-fork-id="10"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-lvar kind-name run" title="13x">owner_class_name</span> <span class="node-and kind-operator run" title="13x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="10"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-lvar kind-name run" title="5x">reflection</span></span></span></span></td></tr><tr><td id="L52" class="nb">52</td><td>        <span class="fork fork-branch fork-run " data-fork-id="9"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-super kind-keyword run" title="5x">super</span><span class="node-super kind-begin run" title="5x">(</span><span class="node-dstr kind-begin run" title="5x">"</span><span class="node-str kind-expression run" title="5x">Cannot have a has_many :through association '</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">owner_class_name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">#</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">' which goes through the polymorphic association '</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">owner_class_name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">#</span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">through_reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">name</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-str kind-expression run" title="5x">'.</span><span class="node-dstr kind-end run" title="5x">"</span><span class="node-super kind-end run" title="5x">)</span></span></td></tr><tr><td id="L53" class="nb">53</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L54" class="nb">54</td><td>        <span class="fork fork-branch fork-run " data-fork-id="9"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Cannot have a has_many :through association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L55" class="nb">55</td><td>      end</td></tr><tr><td id="L56" class="nb">56</td><td>    end</td></tr><tr><td id="L57" class="nb">57</td><td>  end</td></tr><tr><td id="L58" class="nb">58</td><td></td></tr><tr><td id="L59" class="nb">59</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughAssociationPointlessSourceTypeError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L60" class="nb">60</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>, source_reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L61" class="nb">61</td><td>      <span class="fork fork-whole fork-not-run fork-with-uncovered-branches" data-fork-id="11"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="truthy branch not covered"></i><span class="node-if kind-keyword run" title="8x">if</span> <span class="fork fork-whole fork-not-run fork-with-uncovered-branches" data-fork-id="12"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="left-hand side not covered"></i><span class="fork fork-whole fork-not-run fork-with-uncovered-branches" data-fork-id="13"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="left-hand side not covered"></i><span class="node-lvar kind-name run" title="8x">owner_class_name</span> <span class="node-and kind-operator run" title="8x">&amp;&amp;</span> <span class="fork fork-branch fork-not-run " data-fork-id="13"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="never run"></i><span class="node-lvar kind-name not-run" title="never run">reflection</span></span></span> <span class="node-and kind-operator run" title="8x">&amp;&amp;</span> <span class="fork fork-branch fork-not-run " data-fork-id="12"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="never run"></i><span class="node-lvar kind-name not-run" title="never run">source_reflection</span></span></span></span></td></tr><tr><td id="L62" class="nb">62</td><td>        <span class="fork fork-branch fork-not-run " data-fork-id="11"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="never run"></i><span class="node-super kind-keyword not-run" title="never run">super</span><span class="node-super kind-begin not-run" title="never run">(</span><span class="node-dstr kind-begin not-run" title="never run">"</span><span class="node-str kind-expression not-run" title="never run">Cannot have a has_many :through association '</span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">owner_class_name</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">#</span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">name</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">' with a :source_type option if the '</span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">through_reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">class_name</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">#</span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">source_reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">name</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">' is not polymorphic. Try removing :source_type on your association.</span><span class="node-dstr kind-end not-run" title="never run">"</span><span class="node-super kind-end not-run" title="never run">)</span></span></td></tr><tr><td id="L63" class="nb">63</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L64" class="nb">64</td><td>        <span class="fork fork-branch fork-run " data-fork-id="11"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Cannot have a has_many :through association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L65" class="nb">65</td><td>      end</td></tr><tr><td id="L66" class="nb">66</td><td>    end</td></tr><tr><td id="L67" class="nb">67</td><td>  end</td></tr><tr><td id="L68" class="nb">68</td><td></td></tr><tr><td id="L69" class="nb">69</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasOneThroughCantAssociateThroughCollection</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L70" class="nb">70</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>, through_reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L71" class="nb">71</td><td>      <span class="fork fork-whole fork-run " data-fork-id="14"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="node-if kind-keyword run" title="15x">if</span> <span class="fork fork-whole fork-run " data-fork-id="15"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="fork fork-whole fork-run " data-fork-id="16"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="node-lvar kind-name run" title="15x">owner_class_name</span> <span class="node-and kind-operator run" title="15x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="16"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-lvar kind-name run" title="7x">reflection</span></span></span> <span class="node-and kind-operator run" title="15x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="15"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-lvar kind-name run" title="7x">through_reflection</span></span></span></span></td></tr><tr><td id="L72" class="nb">72</td><td>        <span class="fork fork-branch fork-run " data-fork-id="14"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-super kind-keyword run" title="7x">super</span><span class="node-super kind-begin run" title="7x">(</span><span class="node-dstr kind-begin run" title="7x">"</span><span class="node-str kind-expression run" title="7x">Cannot have a has_one :through association '</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">owner_class_name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">#</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">' where the :through association '</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">owner_class_name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">#</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">through_reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">' is a collection. Specify a has_one or belongs_to association in the :through option instead.</span><span class="node-dstr kind-end run" title="7x">"</span><span class="node-super kind-end run" title="7x">)</span></span></td></tr><tr><td id="L73" class="nb">73</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L74" class="nb">74</td><td>        <span class="fork fork-branch fork-run " data-fork-id="14"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Cannot have a has_one :through association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L75" class="nb">75</td><td>      end</td></tr><tr><td id="L76" class="nb">76</td><td>    end</td></tr><tr><td id="L77" class="nb">77</td><td>  end</td></tr><tr><td id="L78" class="nb">78</td><td></td></tr><tr><td id="L79" class="nb">79</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasOneAssociationPolymorphicThroughError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L80" class="nb">80</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L81" class="nb">81</td><td>      <span class="fork fork-whole fork-run " data-fork-id="17"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="node-if kind-keyword run" title="15x">if</span> <span class="fork fork-whole fork-run " data-fork-id="18"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="node-lvar kind-name run" title="15x">owner_class_name</span> <span class="node-and kind-operator run" title="15x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="18"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-lvar kind-name run" title="7x">reflection</span></span></span></span></td></tr><tr><td id="L82" class="nb">82</td><td>        <span class="fork fork-branch fork-run " data-fork-id="17"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-super kind-keyword run" title="7x">super</span><span class="node-super kind-begin run" title="7x">(</span><span class="node-dstr kind-begin run" title="7x">"</span><span class="node-str kind-expression run" title="7x">Cannot have a has_one :through association '</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">owner_class_name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">#</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">' which goes through the polymorphic association '</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">owner_class_name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">#</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">through_reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">'.</span><span class="node-dstr kind-end run" title="7x">"</span><span class="node-super kind-end run" title="7x">)</span></span></td></tr><tr><td id="L83" class="nb">83</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L84" class="nb">84</td><td>        <span class="fork fork-branch fork-run " data-fork-id="17"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Cannot have a has_one :through association."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L85" class="nb">85</td><td>      end</td></tr><tr><td id="L86" class="nb">86</td><td>    end</td></tr><tr><td id="L87" class="nb">87</td><td>  end</td></tr><tr><td id="L88" class="nb">88</td><td></td></tr><tr><td id="L89" class="nb">89</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughSourceAssociationNotFoundError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L90" class="nb">90</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L91" class="nb">91</td><td>      <span class="fork fork-whole fork-not-run fork-with-uncovered-branches" data-fork-id="19"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="truthy branch not covered"></i><span class="node-if kind-keyword run" title="8x">if</span> <span class="node-lvar kind-name run" title="8x">reflection</span></span></td></tr><tr><td id="L92" class="nb">92</td><td>        <span class="fork fork-branch fork-not-run " data-fork-id="19"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="never run"></i><span class="node-lvasgn kind-name not-run" title="never run">through_reflection</span>      <span class="node-lvasgn kind-operator not-run" title="never run">=</span> <span class="node-lvar kind-name not-run" title="never run">reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">through_reflection</span></span></td></tr><tr><td id="L93" class="nb">93</td><td>        <span class="node-lvasgn kind-name not-run" title="never run">source_reflection_names</span> <span class="node-lvasgn kind-operator not-run" title="never run">=</span> <span class="node-lvar kind-name not-run" title="never run">reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">source_reflection_names</span></td></tr><tr><td id="L94" class="nb">94</td><td>        <span class="node-lvasgn kind-name not-run" title="never run">source_associations</span>     <span class="node-lvasgn kind-operator not-run" title="never run">=</span> <span class="node-lvar kind-name not-run" title="never run">reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">through_reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">klass</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">_reflections</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">keys</span></td></tr><tr><td id="L95" class="nb">95</td><td>        <span class="node-super kind-keyword not-run" title="never run">super</span><span class="node-super kind-begin not-run" title="never run">(</span><span class="node-dstr kind-begin not-run" title="never run">"</span><span class="node-str kind-expression not-run" title="never run">Could not find the source association(s) </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">source_reflection_names</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">collect</span>(<span class="node-block_pass kind-operator not-run" title="never run">&amp;</span><span class="node-sym kind-expression not-run" title="never run">:inspect</span>)<span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">to_sentence</span>(<span class="node-sym kind-expression not-run" title="never run">two_words_connector</span><span class="node-pair kind-operator not-run" title="never run">:</span> <span class="node-str kind-expression not-run" title="never run">' or '</span>, <span class="node-sym kind-expression not-run" title="never run">last_word_connector</span><span class="node-pair kind-operator not-run" title="never run">:</span> <span class="node-str kind-expression not-run" title="never run">', or '</span>, <span class="node-sym kind-expression not-run" title="never run">locale</span><span class="node-pair kind-operator not-run" title="never run">:</span> <span class="node-sym kind-expression not-run" title="never run">:en</span>)<span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run"> in model </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">through_reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">klass</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">. Try 'has_many </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">name</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">inspect</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">, :through =&gt; </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">through_reflection</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">name</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">inspect</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">, :source =&gt; &lt;name&gt;'. Is it one of </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">source_associations</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">to_sentence</span>(<span class="node-sym kind-expression not-run" title="never run">two_words_connector</span><span class="node-pair kind-operator not-run" title="never run">:</span> <span class="node-str kind-expression not-run" title="never run">' or '</span>, <span class="node-sym kind-expression not-run" title="never run">last_word_connector</span><span class="node-pair kind-operator not-run" title="never run">:</span> <span class="node-str kind-expression not-run" title="never run">', or '</span>, <span class="node-sym kind-expression not-run" title="never run">locale</span><span class="node-pair kind-operator not-run" title="never run">:</span> <span class="node-sym kind-expression not-run" title="never run">:en</span>)<span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">?</span><span class="node-dstr kind-end not-run" title="never run">"</span><span class="node-super kind-end not-run" title="never run">)</span></td></tr><tr><td id="L96" class="nb">96</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L97" class="nb">97</td><td>        <span class="fork fork-branch fork-run " data-fork-id="19"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Could not find the source association(s)."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L98" class="nb">98</td><td>      end</td></tr><tr><td id="L99" class="nb">99</td><td>    end</td></tr><tr><td id="L100" class="nb">100</td><td>  end</td></tr><tr><td id="L101" class="nb">101</td><td></td></tr><tr><td id="L102" class="nb">102</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughOrderError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L103" class="nb">103</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner_class_name = <span class="node-nil kind-expression run" title="8x">nil</span>, reflection = <span class="node-nil kind-expression run" title="8x">nil</span>, through_reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L104" class="nb">104</td><td>      <span class="fork fork-whole fork-run " data-fork-id="20"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="node-if kind-keyword run" title="15x">if</span> <span class="fork fork-whole fork-run " data-fork-id="21"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="fork fork-whole fork-run " data-fork-id="22"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="15x"></i><span class="node-lvar kind-name run" title="15x">owner_class_name</span> <span class="node-and kind-operator run" title="15x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="22"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-lvar kind-name run" title="7x">reflection</span></span></span> <span class="node-and kind-operator run" title="15x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="21"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-lvar kind-name run" title="7x">through_reflection</span></span></span></span></td></tr><tr><td id="L105" class="nb">105</td><td>        <span class="fork fork-branch fork-run " data-fork-id="20"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7x"></i><span class="node-super kind-keyword run" title="7x">super</span><span class="node-super kind-begin run" title="7x">(</span><span class="node-dstr kind-begin run" title="7x">"</span><span class="node-str kind-expression run" title="7x">Cannot have a has_many :through association '</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">owner_class_name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">#</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">' which goes through '</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">owner_class_name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">#</span><span class="node-begin kind-begin run" title="7x">#{</span><span class="node-lvar kind-name run" title="7x">through_reflection</span><span class="node-send kind-dot run" title="7x">.</span><span class="node-send kind-selector_begin run" title="7x">name</span><span class="node-begin kind-end run" title="7x">}</span><span class="node-str kind-expression run" title="7x">' before the through association is defined.</span><span class="node-dstr kind-end run" title="7x">"</span><span class="node-super kind-end run" title="7x">)</span></span></td></tr><tr><td id="L106" class="nb">106</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L107" class="nb">107</td><td>        <span class="fork fork-branch fork-run " data-fork-id="20"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Cannot have a has_many :through association before the through association is defined."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L108" class="nb">108</td><td>      end</td></tr><tr><td id="L109" class="nb">109</td><td>    end</td></tr><tr><td id="L110" class="nb">110</td><td>  end</td></tr><tr><td id="L111" class="nb">111</td><td></td></tr><tr><td id="L112" class="nb">112</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">ThroughCantAssociateThroughHasOneOrManyReflection</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L113" class="nb">113</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner = <span class="node-nil kind-expression run" title="24x">nil</span>, reflection = <span class="node-nil kind-expression run" title="24x">nil</span>)</td></tr><tr><td id="L114" class="nb">114</td><td>      <span class="fork fork-whole fork-run " data-fork-id="23"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="81x"></i><span class="node-if kind-keyword run" title="81x">if</span> <span class="fork fork-whole fork-run " data-fork-id="24"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="81x"></i><span class="node-lvar kind-name run" title="81x">owner</span> <span class="node-and kind-operator run" title="81x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="24"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="57x"></i><span class="node-lvar kind-name run" title="57x">reflection</span></span></span></span></td></tr><tr><td id="L115" class="nb">115</td><td>        <span class="fork fork-branch fork-run " data-fork-id="23"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="57x"></i><span class="node-super kind-keyword run" title="57x">super</span><span class="node-super kind-begin run" title="57x">(</span><span class="node-dstr kind-begin run" title="57x">"</span><span class="node-str kind-expression run" title="57x">Cannot modify association '</span><span class="node-begin kind-begin run" title="57x">#{</span><span class="node-lvar kind-name run" title="57x">owner</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">class</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">name</span><span class="node-begin kind-end run" title="57x">}</span><span class="node-str kind-expression run" title="57x">#</span><span class="node-begin kind-begin run" title="57x">#{</span><span class="node-lvar kind-name run" title="57x">reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">name</span><span class="node-begin kind-end run" title="57x">}</span><span class="node-str kind-expression run" title="57x">' because the source reflection class '</span><span class="node-begin kind-begin run" title="57x">#{</span><span class="node-lvar kind-name run" title="57x">reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">source_reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">class_name</span><span class="node-begin kind-end run" title="57x">}</span><span class="node-str kind-expression run" title="57x">' is associated to '</span><span class="node-begin kind-begin run" title="57x">#{</span><span class="node-lvar kind-name run" title="57x">reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">through_reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">class_name</span><span class="node-begin kind-end run" title="57x">}</span><span class="node-str kind-expression run" title="57x">' via :</span><span class="node-begin kind-begin run" title="57x">#{</span><span class="node-lvar kind-name run" title="57x">reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">source_reflection</span><span class="node-send kind-dot run" title="57x">.</span><span class="node-send kind-selector_begin run" title="57x">macro</span><span class="node-begin kind-end run" title="57x">}</span><span class="node-str kind-expression run" title="57x">.</span><span class="node-dstr kind-end run" title="57x">"</span><span class="node-super kind-end run" title="57x">)</span></span></td></tr><tr><td id="L116" class="nb">116</td><td>      <span class="node-super kind-else run" title="24x">else</span></td></tr><tr><td id="L117" class="nb">117</td><td>        <span class="fork fork-branch fork-run " data-fork-id="23"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="24x"></i><span class="node-super kind-keyword run" title="24x">super</span><span class="node-super kind-begin run" title="24x">(</span><span class="node-str kind-expression run" title="24x">"Cannot modify association."</span><span class="node-super kind-end run" title="24x">)</span></span></td></tr><tr><td id="L118" class="nb">118</td><td>      end</td></tr><tr><td id="L119" class="nb">119</td><td>    end</td></tr><tr><td id="L120" class="nb">120</td><td>  end</td></tr><tr><td id="L121" class="nb">121</td><td></td></tr><tr><td id="L122" class="nb">122</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">AmbiguousSourceReflectionForThroughAssociation</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> # :nodoc:</td></tr><tr><td id="L123" class="nb">123</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(klass, macro, association_name, options, possible_sources)</td></tr><tr><td id="L124" class="nb">124</td><td>      <span class="node-lvasgn kind-name not-run" title="never run">example_options</span> <span class="node-lvasgn kind-operator not-run" title="never run">=</span> <span class="node-lvar kind-name not-run" title="never run">options</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">dup</span></td></tr><tr><td id="L125" class="nb">125</td><td>      <span class="node-lvar kind-name not-run" title="never run">example_options</span><span class="node-send kind-selector_begin not-run" title="never run">[</span><span class="node-sym kind-expression not-run" title="never run">:source</span><span class="node-send kind-selector_end not-run" title="never run">]</span> <span class="node-send kind-operator not-run" title="never run">=</span> <span class="node-lvar kind-name not-run" title="never run">possible_sources</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">first</span></td></tr><tr><td id="L126" class="nb">126</td><td></td></tr><tr><td id="L127" class="nb">127</td><td>      <span class="node-super kind-keyword not-run" title="never run">super</span><span class="node-super kind-begin not-run" title="never run">(</span><span class="node-str kind-expression not-run" title="never run">"Ambiguous source reflection for through association. Please "</span> \</td></tr><tr><td id="L128" class="nb">128</td><td>            <span class="node-str kind-expression not-run" title="never run">"specify a :source directive on your declaration like:\n"</span> \</td></tr><tr><td id="L129" class="nb">129</td><td>            <span class="node-str kind-expression not-run" title="never run">"\n"</span> \</td></tr><tr><td id="L130" class="nb">130</td><td>            <span class="node-dstr kind-begin not-run" title="never run">"</span><span class="node-str kind-expression not-run" title="never run">  class </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">klass</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run"> &lt; ActiveRecord::Base\n</span><span class="node-dstr kind-end not-run" title="never run">"</span> \</td></tr><tr><td id="L131" class="nb">131</td><td>            <span class="node-dstr kind-begin not-run" title="never run">"</span>    <span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">macro</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run"> :</span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">association_name</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">, </span><span class="node-begin kind-begin not-run" title="never run">#{</span><span class="node-lvar kind-name not-run" title="never run">example_options</span><span class="node-begin kind-end not-run" title="never run">}</span><span class="node-str kind-expression not-run" title="never run">\n</span><span class="node-dstr kind-end not-run" title="never run">"</span> \</td></tr><tr><td id="L132" class="nb">132</td><td>            <span class="node-str kind-expression not-run" title="never run">"  end"</span></td></tr><tr><td id="L133" class="nb">133</td><td>           <span class="node-super kind-end not-run" title="never run">)</span></td></tr><tr><td id="L134" class="nb">134</td><td>    end</td></tr><tr><td id="L135" class="nb">135</td><td>  end</td></tr><tr><td id="L136" class="nb">136</td><td></td></tr><tr><td id="L137" class="nb">137</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughCantAssociateThroughHasOneOrManyReflection</span> &lt; <span class="node-const kind-name run" title="11x">ThroughCantAssociateThroughHasOneOrManyReflection</span> #:nodoc:</td></tr><tr><td id="L138" class="nb">138</td><td>  end</td></tr><tr><td id="L139" class="nb">139</td><td></td></tr><tr><td id="L140" class="nb">140</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasOneThroughCantAssociateThroughHasOneOrManyReflection</span> &lt; <span class="node-const kind-name run" title="11x">ThroughCantAssociateThroughHasOneOrManyReflection</span> #:nodoc:</td></tr><tr><td id="L141" class="nb">141</td><td>  end</td></tr><tr><td id="L142" class="nb">142</td><td></td></tr><tr><td id="L143" class="nb">143</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">ThroughNestedAssociationsAreReadonly</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L144" class="nb">144</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(owner = <span class="node-nil kind-expression run" title="24x">nil</span>, reflection = <span class="node-nil kind-expression run" title="24x">nil</span>)</td></tr><tr><td id="L145" class="nb">145</td><td>      <span class="fork fork-whole fork-run " data-fork-id="25"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="80x"></i><span class="node-if kind-keyword run" title="80x">if</span> <span class="fork fork-whole fork-run " data-fork-id="26"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="80x"></i><span class="node-lvar kind-name run" title="80x">owner</span> <span class="node-and kind-operator run" title="80x">&amp;&amp;</span> <span class="fork fork-branch fork-run " data-fork-id="26"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="56x"></i><span class="node-lvar kind-name run" title="56x">reflection</span></span></span></span></td></tr><tr><td id="L146" class="nb">146</td><td>        <span class="fork fork-branch fork-run " data-fork-id="25"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="56x"></i><span class="node-super kind-keyword run" title="56x">super</span><span class="node-super kind-begin run" title="56x">(</span><span class="node-dstr kind-begin run" title="56x">"</span><span class="node-str kind-expression run" title="56x">Cannot modify association '</span><span class="node-begin kind-begin run" title="56x">#{</span><span class="node-lvar kind-name run" title="56x">owner</span><span class="node-send kind-dot run" title="56x">.</span><span class="node-send kind-selector_begin run" title="56x">class</span><span class="node-send kind-dot run" title="56x">.</span><span class="node-send kind-selector_begin run" title="56x">name</span><span class="node-begin kind-end run" title="56x">}</span><span class="node-str kind-expression run" title="56x">#</span><span class="node-begin kind-begin run" title="56x">#{</span><span class="node-lvar kind-name run" title="56x">reflection</span><span class="node-send kind-dot run" title="56x">.</span><span class="node-send kind-selector_begin run" title="56x">name</span><span class="node-begin kind-end run" title="56x">}</span><span class="node-str kind-expression run" title="56x">' because it goes through more than one other association.</span><span class="node-dstr kind-end run" title="56x">"</span><span class="node-super kind-end run" title="56x">)</span></span></td></tr><tr><td id="L147" class="nb">147</td><td>      <span class="node-super kind-else run" title="24x">else</span></td></tr><tr><td id="L148" class="nb">148</td><td>        <span class="fork fork-branch fork-run " data-fork-id="25"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="24x"></i><span class="node-super kind-keyword run" title="24x">super</span><span class="node-super kind-begin run" title="24x">(</span><span class="node-str kind-expression run" title="24x">"Through nested associations are read-only."</span><span class="node-super kind-end run" title="24x">)</span></span></td></tr><tr><td id="L149" class="nb">149</td><td>      end</td></tr><tr><td id="L150" class="nb">150</td><td>    end</td></tr><tr><td id="L151" class="nb">151</td><td>  end</td></tr><tr><td id="L152" class="nb">152</td><td></td></tr><tr><td id="L153" class="nb">153</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasManyThroughNestedAssociationsAreReadonly</span> &lt; <span class="node-const kind-name run" title="11x">ThroughNestedAssociationsAreReadonly</span> #:nodoc:</td></tr><tr><td id="L154" class="nb">154</td><td>  end</td></tr><tr><td id="L155" class="nb">155</td><td></td></tr><tr><td id="L156" class="nb">156</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">HasOneThroughNestedAssociationsAreReadonly</span> &lt; <span class="node-const kind-name run" title="11x">ThroughNestedAssociationsAreReadonly</span> #:nodoc:</td></tr><tr><td id="L157" class="nb">157</td><td>  end</td></tr><tr><td id="L158" class="nb">158</td><td></td></tr><tr><td id="L159" class="nb">159</td><td>  # This error is raised when trying to eager load a polymorphic association using a JOIN.</td></tr><tr><td id="L160" class="nb">160</td><td>  # Eager loading polymorphic associations is only possible with</td></tr><tr><td id="L161" class="nb">161</td><td>  # {ActiveRecord::Relation#preload}[rdoc-ref:QueryMethods#preload].</td></tr><tr><td id="L162" class="nb">162</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">EagerLoadPolymorphicError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span></td></tr><tr><td id="L163" class="nb">163</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(reflection = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L164" class="nb">164</td><td>      <span class="fork fork-whole fork-run " data-fork-id="27"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="13x"></i><span class="node-if kind-keyword run" title="13x">if</span> <span class="node-lvar kind-name run" title="13x">reflection</span></span></td></tr><tr><td id="L165" class="nb">165</td><td>        <span class="fork fork-branch fork-run " data-fork-id="27"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="5x"></i><span class="node-super kind-keyword run" title="5x">super</span><span class="node-super kind-begin run" title="5x">(</span><span class="node-dstr kind-begin run" title="5x">"</span><span class="node-str kind-expression run" title="5x">Cannot eagerly load the polymorphic association </span><span class="node-begin kind-begin run" title="5x">#{</span><span class="node-lvar kind-name run" title="5x">reflection</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">name</span><span class="node-send kind-dot run" title="5x">.</span><span class="node-send kind-selector_begin run" title="5x">inspect</span><span class="node-begin kind-end run" title="5x">}</span><span class="node-dstr kind-end run" title="5x">"</span><span class="node-super kind-end run" title="5x">)</span></span></td></tr><tr><td id="L166" class="nb">166</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L167" class="nb">167</td><td>        <span class="fork fork-branch fork-run " data-fork-id="27"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Eager load polymorphic error."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L168" class="nb">168</td><td>      end</td></tr><tr><td id="L169" class="nb">169</td><td>    end</td></tr><tr><td id="L170" class="nb">170</td><td>  end</td></tr><tr><td id="L171" class="nb">171</td><td></td></tr><tr><td id="L172" class="nb">172</td><td>  # This error is raised when trying to destroy a parent instance in N:1 or 1:1 associations</td></tr><tr><td id="L173" class="nb">173</td><td>  # (has_many, has_one) when there is at least 1 child associated instance.</td></tr><tr><td id="L174" class="nb">174</td><td>  # ex: if @project.tasks.size &gt; 0, DeleteRestrictionError will be raised when trying to destroy @project</td></tr><tr><td id="L175" class="nb">175</td><td>  <span class="node-class kind-keyword run" title="11x">class</span> <span class="node-const kind-name run" title="11x">DeleteRestrictionError</span> &lt; <span class="node-const kind-name run" title="11x">ActiveRecordError</span> #:nodoc:</td></tr><tr><td id="L176" class="nb">176</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize</span>(name = <span class="node-nil kind-expression run" title="8x">nil</span>)</td></tr><tr><td id="L177" class="nb">177</td><td>      <span class="fork fork-whole fork-run " data-fork-id="28"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="22x"></i><span class="node-if kind-keyword run" title="22x">if</span> <span class="node-lvar kind-name run" title="22x">name</span></span></td></tr><tr><td id="L178" class="nb">178</td><td>        <span class="fork fork-branch fork-run " data-fork-id="28"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="14x"></i><span class="node-super kind-keyword run" title="14x">super</span><span class="node-super kind-begin run" title="14x">(</span><span class="node-dstr kind-begin run" title="14x">"</span><span class="node-str kind-expression run" title="14x">Cannot delete record because of dependent </span><span class="node-begin kind-begin run" title="14x">#{</span><span class="node-lvar kind-name run" title="14x">name</span><span class="node-begin kind-end run" title="14x">}</span><span class="node-dstr kind-end run" title="14x">"</span><span class="node-super kind-end run" title="14x">)</span></span></td></tr><tr><td id="L179" class="nb">179</td><td>      <span class="node-super kind-else run" title="8x">else</span></td></tr><tr><td id="L180" class="nb">180</td><td>        <span class="fork fork-branch fork-run " data-fork-id="28"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="8x"></i><span class="node-super kind-keyword run" title="8x">super</span><span class="node-super kind-begin run" title="8x">(</span><span class="node-str kind-expression run" title="8x">"Delete restriction error."</span><span class="node-super kind-end run" title="8x">)</span></span></td></tr><tr><td id="L181" class="nb">181</td><td>      end</td></tr><tr><td id="L182" class="nb">182</td><td>    end</td></tr><tr><td id="L183" class="nb">183</td><td>  end</td></tr><tr><td id="L184" class="nb">184</td><td></td></tr><tr><td id="L185" class="nb">185</td><td>  # See ActiveRecord::Associations::ClassMethods for documentation.</td></tr><tr><td id="L186" class="nb">186</td><td>  <span class="node-module kind-keyword run" title="11x">module</span> <span class="node-const kind-name run" title="11x">Associations</span> # :nodoc:</td></tr><tr><td id="L187" class="nb">187</td><td>    <span class="node-send kind-selector_begin run" title="11x">extend</span> <span class="node-const kind-name run" title="11x">ActiveSupport</span><span class="node-const kind-double_colon run" title="11x">::</span><span class="node-const kind-name run" title="11x">Autoload</span></td></tr><tr><td id="L188" class="nb">188</td><td>    <span class="node-send kind-selector_begin run" title="11x">extend</span> <span class="node-const kind-name run" title="11x">ActiveSupport</span><span class="node-const kind-double_colon run" title="11x">::</span><span class="node-const kind-name run" title="11x">Concern</span></td></tr><tr><td id="L189" class="nb">189</td><td></td></tr><tr><td id="L190" class="nb">190</td><td>    # These classes will be loaded when associations are created.</td></tr><tr><td id="L191" class="nb">191</td><td>    # So there is no need to eager load them.</td></tr><tr><td id="L192" class="nb">192</td><td>    <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:Association</span></td></tr><tr><td id="L193" class="nb">193</td><td>    <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:SingularAssociation</span></td></tr><tr><td id="L194" class="nb">194</td><td>    <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:CollectionAssociation</span></td></tr><tr><td id="L195" class="nb">195</td><td>    <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:ForeignAssociation</span></td></tr><tr><td id="L196" class="nb">196</td><td>    <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:CollectionProxy</span></td></tr><tr><td id="L197" class="nb">197</td><td>    <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:ThroughAssociation</span></td></tr><tr><td id="L198" class="nb">198</td><td></td></tr><tr><td id="L199" class="nb">199</td><td>    <span class="node-module kind-keyword run" title="11x">module</span> <span class="node-const kind-name run" title="11x">Builder</span> #:nodoc:</td></tr><tr><td id="L200" class="nb">200</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:Association</span>,           <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/association"</span></td></tr><tr><td id="L201" class="nb">201</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:SingularAssociation</span>,   <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/singular_association"</span></td></tr><tr><td id="L202" class="nb">202</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:CollectionAssociation</span>, <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/collection_association"</span></td></tr><tr><td id="L203" class="nb">203</td><td></td></tr><tr><td id="L204" class="nb">204</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:BelongsTo</span>,           <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/belongs_to"</span></td></tr><tr><td id="L205" class="nb">205</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasOne</span>,              <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/has_one"</span></td></tr><tr><td id="L206" class="nb">206</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasMany</span>,             <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/has_many"</span></td></tr><tr><td id="L207" class="nb">207</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasAndBelongsToMany</span>, <span class="node-str kind-expression run" title="11x">"active_record/associations/builder/has_and_belongs_to_many"</span></td></tr><tr><td id="L208" class="nb">208</td><td>    end</td></tr><tr><td id="L209" class="nb">209</td><td></td></tr><tr><td id="L210" class="nb">210</td><td>    <span class="node-send kind-selector_begin run" title="11x">eager_autoload</span> do</td></tr><tr><td id="L211" class="nb">211</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:BelongsToAssociation</span></td></tr><tr><td id="L212" class="nb">212</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:BelongsToPolymorphicAssociation</span></td></tr><tr><td id="L213" class="nb">213</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasManyAssociation</span></td></tr><tr><td id="L214" class="nb">214</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasManyThroughAssociation</span></td></tr><tr><td id="L215" class="nb">215</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasOneAssociation</span></td></tr><tr><td id="L216" class="nb">216</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:HasOneThroughAssociation</span></td></tr><tr><td id="L217" class="nb">217</td><td></td></tr><tr><td id="L218" class="nb">218</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:Preloader</span></td></tr><tr><td id="L219" class="nb">219</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:JoinDependency</span></td></tr><tr><td id="L220" class="nb">220</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:AssociationScope</span></td></tr><tr><td id="L221" class="nb">221</td><td>      <span class="node-send kind-selector_begin run" title="11x">autoload</span> <span class="node-sym kind-expression run" title="11x">:AliasTracker</span></td></tr><tr><td id="L222" class="nb">222</td><td>    end</td></tr><tr><td id="L223" class="nb">223</td><td></td></tr><tr><td id="L224" class="nb">224</td><td>    <span class="node-defs kind-keyword run" title="11x">def</span> <span class="node-self kind-expression run" title="11x">self</span><span class="node-defs kind-operator run" title="11x">.</span><span class="node-defs kind-name run" title="11x">eager_load!</span></td></tr><tr><td id="L225" class="nb">225</td><td>      <span class="node-zsuper kind-keyword not-run" title="never run">super</span></td></tr><tr><td id="L226" class="nb">226</td><td>      <span class="node-const kind-name not-run" title="never run">Preloader</span><span class="node-send kind-dot not-run" title="never run">.</span><span class="node-send kind-selector_begin not-run" title="never run">eager_load!</span></td></tr><tr><td id="L227" class="nb">227</td><td>    end</td></tr><tr><td id="L228" class="nb">228</td><td></td></tr><tr><td id="L229" class="nb">229</td><td>    # Returns the association instance for the given name, instantiating it if it doesn't already exist</td></tr><tr><td id="L230" class="nb">230</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">association</span>(name) #:nodoc:</td></tr><tr><td id="L231" class="nb">231</td><td>      <span class="node-lvasgn kind-name run" title="173297x">association</span> <span class="node-lvasgn kind-operator run" title="173297x">=</span> <span class="node-send kind-selector_begin run" title="173297x">association_instance_get</span>(<span class="node-lvar kind-name run" title="173297x">name</span>)</td></tr><tr><td id="L232" class="nb">232</td><td></td></tr><tr><td id="L233" class="nb">233</td><td>      <span class="fork fork-whole fork-run " data-fork-id="29"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="173297x"></i><span class="node-if kind-keyword run" title="173297x">if</span> <span class="node-lvar kind-name run" title="173297x">association</span><span class="node-send kind-dot run" title="173297x">.</span><span class="node-send kind-selector_begin run" title="173297x">nil?</span></span></td></tr><tr><td id="L234" class="nb">234</td><td>        <span class="fork fork-whole fork-run " data-fork-id="30"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="70526x"></i><span class="fork fork-branch fork-run " data-fork-id="29"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="70526x"></i><span class="node-if kind-keyword run" title="70526x">unless</span> <span class="node-lvasgn kind-name run" title="70526x">reflection</span> <span class="node-lvasgn kind-operator run" title="70526x">=</span> <span class="node-self kind-expression run" title="70526x">self</span><span class="node-send kind-dot run" title="70526x">.</span><span class="node-send kind-selector_begin run" title="70526x">class</span><span class="node-send kind-dot run" title="70526x">.</span><span class="node-send kind-selector_begin run" title="70526x">_reflect_on_association</span>(<span class="node-lvar kind-name run" title="70526x">name</span>)</span></span></td></tr><tr><td id="L235" class="nb">235</td><td>          <span class="fork fork-branch fork-run " data-fork-id="30"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="40x"></i><span class="node-send kind-selector_begin run" title="40x">raise</span> <span class="node-const kind-name run" title="40x">AssociationNotFoundError</span><span class="node-send kind-dot run" title="40x">.</span><span class="node-send kind-selector_begin run" title="40x">new</span>(<span class="node-self kind-expression run" title="40x">self</span>, <span class="node-lvar kind-name run" title="40x">name</span>)</span></td></tr><tr><td id="L236" class="nb">236</td><td>        end</td></tr><tr><td id="L237" class="nb">237</td><td>        <span class="node-lvasgn kind-name run" title="70425x">association</span> <span class="node-lvasgn kind-operator run" title="70425x">=</span> <span class="node-lvar kind-name run" title="70486x">reflection</span><span class="node-send kind-dot run" title="70486x">.</span><span class="node-send kind-selector_begin run" title="70486x">association_class</span><span class="node-send kind-dot run" title="70486x">.</span><span class="node-send kind-selector_begin run" title="70486x">new</span>(<span class="node-self kind-expression run" title="70486x">self</span>, <span class="node-lvar kind-name run" title="70486x">reflection</span>)</td></tr><tr><td id="L238" class="nb">238</td><td>        <span class="node-send kind-selector_begin run" title="70425x">association_instance_set</span>(<span class="node-lvar kind-name run" title="70425x">name</span>, <span class="node-lvar kind-name run" title="70425x">association</span>)</td></tr><tr><td id="L239" class="nb">239</td><td>      end</td></tr><tr><td id="L240" class="nb">240</td><td></td></tr><tr><td id="L241" class="nb">241</td><td>      <span class="node-lvar kind-name run" title="173196x">association</span></td></tr><tr><td id="L242" class="nb">242</td><td>    end</td></tr><tr><td id="L243" class="nb">243</td><td></td></tr><tr><td id="L244" class="nb">244</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">association_cached?</span>(name) # :nodoc</td></tr><tr><td id="L245" class="nb">245</td><td>      <span class="node-ivar kind-name run" title="2390x">@association_cache</span><span class="node-send kind-dot run" title="2390x">.</span><span class="node-send kind-selector_begin run" title="2390x">key?</span>(<span class="node-lvar kind-name run" title="2390x">name</span>)</td></tr><tr><td id="L246" class="nb">246</td><td>    end</td></tr><tr><td id="L247" class="nb">247</td><td></td></tr><tr><td id="L248" class="nb">248</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">initialize_dup</span>(*) # :nodoc:</td></tr><tr><td id="L249" class="nb">249</td><td>      <span class="node-ivasgn kind-name run" title="204x">@association_cache</span> <span class="node-ivasgn kind-operator run" title="204x">=</span> <span class="node-hash kind-begin run" title="204x">{</span><span class="node-hash kind-end run" title="204x">}</span></td></tr><tr><td id="L250" class="nb">250</td><td>      <span class="node-zsuper kind-keyword run" title="204x">super</span></td></tr><tr><td id="L251" class="nb">251</td><td>    end</td></tr><tr><td id="L252" class="nb">252</td><td></td></tr><tr><td id="L253" class="nb">253</td><td>    <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">reload</span>(*) # :nodoc:</td></tr><tr><td id="L254" class="nb">254</td><td>      <span class="node-send kind-selector_begin run" title="4821x">clear_association_cache</span></td></tr><tr><td id="L255" class="nb">255</td><td>      <span class="node-zsuper kind-keyword run" title="4821x">super</span></td></tr><tr><td id="L256" class="nb">256</td><td>    end</td></tr><tr><td id="L257" class="nb">257</td><td></td></tr><tr><td id="L258" class="nb">258</td><td>    <span class="node-send kind-selector_begin run" title="11x">private</span></td></tr><tr><td id="L259" class="nb">259</td><td>      # Clears out the association cache.</td></tr><tr><td id="L260" class="nb">260</td><td>      <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">clear_association_cache</span></td></tr><tr><td id="L261" class="nb">261</td><td>        <span class="fork fork-whole fork-run " data-fork-id="31"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="4821x"></i><span class="fork fork-branch fork-run " data-fork-id="31"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="4767x"></i><span class="node-ivar kind-name run" title="4767x">@association_cache</span><span class="node-send kind-dot run" title="4767x">.</span><span class="node-send kind-selector_begin run" title="4767x">clear</span></span> <span class="node-if kind-keyword run" title="4821x">if</span> <span class="node-send kind-selector_begin run" title="4821x">persisted?</span></span></td></tr><tr><td id="L262" class="nb">262</td><td>      end</td></tr><tr><td id="L263" class="nb">263</td><td></td></tr><tr><td id="L264" class="nb">264</td><td>      <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">init_internals</span></td></tr><tr><td id="L265" class="nb">265</td><td>        <span class="node-ivasgn kind-name run" title="152074x">@association_cache</span> <span class="node-ivasgn kind-operator run" title="152074x">=</span> <span class="node-hash kind-begin run" title="152074x">{</span><span class="node-hash kind-end run" title="152074x">}</span></td></tr><tr><td id="L266" class="nb">266</td><td>        <span class="node-zsuper kind-keyword run" title="152074x">super</span></td></tr><tr><td id="L267" class="nb">267</td><td>      end</td></tr><tr><td id="L268" class="nb">268</td><td></td></tr><tr><td id="L269" class="nb">269</td><td>      # Returns the specified association instance if it exists, +nil+ otherwise.</td></tr><tr><td id="L270" class="nb">270</td><td>      <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">association_instance_get</span>(name)</td></tr><tr><td id="L271" class="nb">271</td><td>        <span class="node-ivar kind-name run" title="827020x">@association_cache</span><span class="node-send kind-selector_begin run" title="827020x">[</span><span class="node-lvar kind-name run" title="827020x">name</span><span class="node-send kind-selector_end run" title="827020x">]</span></td></tr><tr><td id="L272" class="nb">272</td><td>      end</td></tr><tr><td id="L273" class="nb">273</td><td></td></tr><tr><td id="L274" class="nb">274</td><td>      # Set the specified association instance.</td></tr><tr><td id="L275" class="nb">275</td><td>      <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">association_instance_set</span>(name, association)</td></tr><tr><td id="L276" class="nb">276</td><td>        <span class="node-ivar kind-name run" title="70425x">@association_cache</span><span class="node-send kind-selector_begin run" title="70425x">[</span><span class="node-lvar kind-name run" title="70425x">name</span><span class="node-send kind-selector_end run" title="70425x">]</span> <span class="node-send kind-operator run" title="70425x">=</span> <span class="node-lvar kind-name run" title="70425x">association</span></td></tr><tr><td id="L277" class="nb">277</td><td>      end</td></tr><tr><td id="L278" class="nb">278</td><td></td></tr><tr><td id="L279" class="nb">279</td><td>      # \Associations are a set of macro-like class methods for tying objects together through</td></tr><tr><td id="L280" class="nb">280</td><td>      # foreign keys. They express relationships like "Project has one Project Manager"</td></tr><tr><td id="L281" class="nb">281</td><td>      # or "Project belongs to a Portfolio". Each macro adds a number of methods to the</td></tr><tr><td id="L282" class="nb">282</td><td>      # class which are specialized according to the collection or association symbol and the</td></tr><tr><td id="L283" class="nb">283</td><td>      # options hash. It works much the same way as Ruby's own &lt;tt&gt;attr*&lt;/tt&gt;</td></tr><tr><td id="L284" class="nb">284</td><td>      # methods.</td></tr><tr><td id="L285" class="nb">285</td><td>      #</td></tr><tr><td id="L286" class="nb">286</td><td>      #   class Project &lt; ActiveRecord::Base</td></tr><tr><td id="L287" class="nb">287</td><td>      #     belongs_to              :portfolio</td></tr><tr><td id="L288" class="nb">288</td><td>      #     has_one                 :project_manager</td></tr><tr><td id="L289" class="nb">289</td><td>      #     has_many                :milestones</td></tr><tr><td id="L290" class="nb">290</td><td>      #     has_and_belongs_to_many :categories</td></tr><tr><td id="L291" class="nb">291</td><td>      #   end</td></tr><tr><td id="L292" class="nb">292</td><td>      #</td></tr><tr><td id="L293" class="nb">293</td><td>      # The project class now has the following methods (and more) to ease the traversal and</td></tr><tr><td id="L294" class="nb">294</td><td>      # manipulation of its relationships:</td></tr><tr><td id="L295" class="nb">295</td><td>      # * &lt;tt&gt;Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?&lt;/tt&gt;</td></tr><tr><td id="L296" class="nb">296</td><td>      # * &lt;tt&gt;Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,&lt;/tt&gt;</td></tr><tr><td id="L297" class="nb">297</td><td>      # * &lt;tt&gt;Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones&lt;&lt;(milestone),&lt;/tt&gt;</td></tr><tr><td id="L298" class="nb">298</td><td>      #   &lt;tt&gt;Project#milestones.delete(milestone), Project#milestones.destroy(milestone), Project#milestones.find(milestone_id),&lt;/tt&gt;</td></tr><tr><td id="L299" class="nb">299</td><td>      #   &lt;tt&gt;Project#milestones.build, Project#milestones.create&lt;/tt&gt;</td></tr><tr><td id="L300" class="nb">300</td><td>      # * &lt;tt&gt;Project#categories.empty?, Project#categories.size, Project#categories, Project#categories&lt;&lt;(category1),&lt;/tt&gt;</td></tr><tr><td id="L301" class="nb">301</td><td>      #   &lt;tt&gt;Project#categories.delete(category1), Project#categories.destroy(category1)&lt;/tt&gt;</td></tr><tr><td id="L302" class="nb">302</td><td>      #</td></tr><tr><td id="L303" class="nb">303</td><td>      # === A word of warning</td></tr><tr><td id="L304" class="nb">304</td><td>      #</td></tr><tr><td id="L305" class="nb">305</td><td>      # Don't create associations that have the same name as {instance methods}[rdoc-ref:ActiveRecord::Core] of</td></tr><tr><td id="L306" class="nb">306</td><td>      # &lt;tt&gt;ActiveRecord::Base&lt;/tt&gt;. Since the association adds a method with that name to</td></tr><tr><td id="L307" class="nb">307</td><td>      # its model, using an association with the same name as one provided by &lt;tt&gt;ActiveRecord::Base&lt;/tt&gt; will override the method inherited through &lt;tt&gt;ActiveRecord::Base&lt;/tt&gt; and will break things.</td></tr><tr><td id="L308" class="nb">308</td><td>      # For instance, +attributes+ and +connection+ would be bad choices for association names, because those names already exist in the list of &lt;tt&gt;ActiveRecord::Base&lt;/tt&gt; instance methods.</td></tr><tr><td id="L309" class="nb">309</td><td>      #</td></tr><tr><td id="L310" class="nb">310</td><td>      # == Auto-generated methods</td></tr><tr><td id="L311" class="nb">311</td><td>      # See also Instance Public methods below for more details.</td></tr><tr><td id="L312" class="nb">312</td><td>      #</td></tr><tr><td id="L313" class="nb">313</td><td>      # === Singular associations (one-to-one)</td></tr><tr><td id="L314" class="nb">314</td><td>      #                                     |            |  belongs_to  |</td></tr><tr><td id="L315" class="nb">315</td><td>      #   generated methods                 | belongs_to | :polymorphic | has_one</td></tr><tr><td id="L316" class="nb">316</td><td>      #   ----------------------------------+------------+--------------+---------</td></tr><tr><td id="L317" class="nb">317</td><td>      #   other                             |     X      |      X       |    X</td></tr><tr><td id="L318" class="nb">318</td><td>      #   other=(other)                     |     X      |      X       |    X</td></tr><tr><td id="L319" class="nb">319</td><td>      #   build_other(attributes={})        |     X      |              |    X</td></tr><tr><td id="L320" class="nb">320</td><td>      #   create_other(attributes={})       |     X      |              |    X</td></tr><tr><td id="L321" class="nb">321</td><td>      #   create_other!(attributes={})      |     X      |              |    X</td></tr><tr><td id="L322" class="nb">322</td><td>      #   reload_other                      |     X      |      X       |    X</td></tr><tr><td id="L323" class="nb">323</td><td>      #</td></tr><tr><td id="L324" class="nb">324</td><td>      # === Collection associations (one-to-many / many-to-many)</td></tr><tr><td id="L325" class="nb">325</td><td>      #                                     |       |          | has_many</td></tr><tr><td id="L326" class="nb">326</td><td>      #   generated methods                 | habtm | has_many | :through</td></tr><tr><td id="L327" class="nb">327</td><td>      #   ----------------------------------+-------+----------+----------</td></tr><tr><td id="L328" class="nb">328</td><td>      #   others                            |   X   |    X     |    X</td></tr><tr><td id="L329" class="nb">329</td><td>      #   others=(other,other,...)          |   X   |    X     |    X</td></tr><tr><td id="L330" class="nb">330</td><td>      #   other_ids                         |   X   |    X     |    X</td></tr><tr><td id="L331" class="nb">331</td><td>      #   other_ids=(id,id,...)             |   X   |    X     |    X</td></tr><tr><td id="L332" class="nb">332</td><td>      #   others&lt;&lt;                          |   X   |    X     |    X</td></tr><tr><td id="L333" class="nb">333</td><td>      #   others.push                       |   X   |    X     |    X</td></tr><tr><td id="L334" class="nb">334</td><td>      #   others.concat                     |   X   |    X     |    X</td></tr><tr><td id="L335" class="nb">335</td><td>      #   others.build(attributes={})       |   X   |    X     |    X</td></tr><tr><td id="L336" class="nb">336</td><td>      #   others.create(attributes={})      |   X   |    X     |    X</td></tr><tr><td id="L337" class="nb">337</td><td>      #   others.create!(attributes={})     |   X   |    X     |    X</td></tr><tr><td id="L338" class="nb">338</td><td>      #   others.size                       |   X   |    X     |    X</td></tr><tr><td id="L339" class="nb">339</td><td>      #   others.length                     |   X   |    X     |    X</td></tr><tr><td id="L340" class="nb">340</td><td>      #   others.count                      |   X   |    X     |    X</td></tr><tr><td id="L341" class="nb">341</td><td>      #   others.sum(*args)                 |   X   |    X     |    X</td></tr><tr><td id="L342" class="nb">342</td><td>      #   others.empty?                     |   X   |    X     |    X</td></tr><tr><td id="L343" class="nb">343</td><td>      #   others.clear                      |   X   |    X     |    X</td></tr><tr><td id="L344" class="nb">344</td><td>      #   others.delete(other,other,...)    |   X   |    X     |    X</td></tr><tr><td id="L345" class="nb">345</td><td>      #   others.delete_all                 |   X   |    X     |    X</td></tr><tr><td id="L346" class="nb">346</td><td>      #   others.destroy(other,other,...)   |   X   |    X     |    X</td></tr><tr><td id="L347" class="nb">347</td><td>      #   others.destroy_all                |   X   |    X     |    X</td></tr><tr><td id="L348" class="nb">348</td><td>      #   others.find(*args)                |   X   |    X     |    X</td></tr><tr><td id="L349" class="nb">349</td><td>      #   others.exists?                    |   X   |    X     |    X</td></tr><tr><td id="L350" class="nb">350</td><td>      #   others.distinct                   |   X   |    X     |    X</td></tr><tr><td id="L351" class="nb">351</td><td>      #   others.reset                      |   X   |    X     |    X</td></tr><tr><td id="L352" class="nb">352</td><td>      #   others.reload                     |   X   |    X     |    X</td></tr><tr><td id="L353" class="nb">353</td><td>      #</td></tr><tr><td id="L354" class="nb">354</td><td>      # === Overriding generated methods</td></tr><tr><td id="L355" class="nb">355</td><td>      #</td></tr><tr><td id="L356" class="nb">356</td><td>      # Association methods are generated in a module included into the model</td></tr><tr><td id="L357" class="nb">357</td><td>      # class, making overrides easy. The original generated method can thus be</td></tr><tr><td id="L358" class="nb">358</td><td>      # called with +super+:</td></tr><tr><td id="L359" class="nb">359</td><td>      #</td></tr><tr><td id="L360" class="nb">360</td><td>      #   class Car &lt; ActiveRecord::Base</td></tr><tr><td id="L361" class="nb">361</td><td>      #     belongs_to :owner</td></tr><tr><td id="L362" class="nb">362</td><td>      #     belongs_to :old_owner</td></tr><tr><td id="L363" class="nb">363</td><td>      #</td></tr><tr><td id="L364" class="nb">364</td><td>      #     def owner=(new_owner)</td></tr><tr><td id="L365" class="nb">365</td><td>      #       self.old_owner = self.owner</td></tr><tr><td id="L366" class="nb">366</td><td>      #       super</td></tr><tr><td id="L367" class="nb">367</td><td>      #     end</td></tr><tr><td id="L368" class="nb">368</td><td>      #   end</td></tr><tr><td id="L369" class="nb">369</td><td>      #</td></tr><tr><td id="L370" class="nb">370</td><td>      # The association methods module is included immediately after the</td></tr><tr><td id="L371" class="nb">371</td><td>      # generated attributes methods module, meaning an association will</td></tr><tr><td id="L372" class="nb">372</td><td>      # override the methods for an attribute with the same name.</td></tr><tr><td id="L373" class="nb">373</td><td>      #</td></tr><tr><td id="L374" class="nb">374</td><td>      # == Cardinality and associations</td></tr><tr><td id="L375" class="nb">375</td><td>      #</td></tr><tr><td id="L376" class="nb">376</td><td>      # Active Record associations can be used to describe one-to-one, one-to-many and many-to-many</td></tr><tr><td id="L377" class="nb">377</td><td>      # relationships between models. Each model uses an association to describe its role in</td></tr><tr><td id="L378" class="nb">378</td><td>      # the relation. The #belongs_to association is always used in the model that has</td></tr><tr><td id="L379" class="nb">379</td><td>      # the foreign key.</td></tr><tr><td id="L380" class="nb">380</td><td>      #</td></tr><tr><td id="L381" class="nb">381</td><td>      # === One-to-one</td></tr><tr><td id="L382" class="nb">382</td><td>      #</td></tr><tr><td id="L383" class="nb">383</td><td>      # Use #has_one in the base, and #belongs_to in the associated model.</td></tr><tr><td id="L384" class="nb">384</td><td>      #</td></tr><tr><td id="L385" class="nb">385</td><td>      #   class Employee &lt; ActiveRecord::Base</td></tr><tr><td id="L386" class="nb">386</td><td>      #     has_one :office</td></tr><tr><td id="L387" class="nb">387</td><td>      #   end</td></tr><tr><td id="L388" class="nb">388</td><td>      #   class Office &lt; ActiveRecord::Base</td></tr><tr><td id="L389" class="nb">389</td><td>      #     belongs_to :employee    # foreign key - employee_id</td></tr><tr><td id="L390" class="nb">390</td><td>      #   end</td></tr><tr><td id="L391" class="nb">391</td><td>      #</td></tr><tr><td id="L392" class="nb">392</td><td>      # === One-to-many</td></tr><tr><td id="L393" class="nb">393</td><td>      #</td></tr><tr><td id="L394" class="nb">394</td><td>      # Use #has_many in the base, and #belongs_to in the associated model.</td></tr><tr><td id="L395" class="nb">395</td><td>      #</td></tr><tr><td id="L396" class="nb">396</td><td>      #   class Manager &lt; ActiveRecord::Base</td></tr><tr><td id="L397" class="nb">397</td><td>      #     has_many :employees</td></tr><tr><td id="L398" class="nb">398</td><td>      #   end</td></tr><tr><td id="L399" class="nb">399</td><td>      #   class Employee &lt; ActiveRecord::Base</td></tr><tr><td id="L400" class="nb">400</td><td>      #     belongs_to :manager     # foreign key - manager_id</td></tr><tr><td id="L401" class="nb">401</td><td>      #   end</td></tr><tr><td id="L402" class="nb">402</td><td>      #</td></tr><tr><td id="L403" class="nb">403</td><td>      # === Many-to-many</td></tr><tr><td id="L404" class="nb">404</td><td>      #</td></tr><tr><td id="L405" class="nb">405</td><td>      # There are two ways to build a many-to-many relationship.</td></tr><tr><td id="L406" class="nb">406</td><td>      #</td></tr><tr><td id="L407" class="nb">407</td><td>      # The first way uses a #has_many association with the &lt;tt&gt;:through&lt;/tt&gt; option and a join model, so</td></tr><tr><td id="L408" class="nb">408</td><td>      # there are two stages of associations.</td></tr><tr><td id="L409" class="nb">409</td><td>      #</td></tr><tr><td id="L410" class="nb">410</td><td>      #   class Assignment &lt; ActiveRecord::Base</td></tr><tr><td id="L411" class="nb">411</td><td>      #     belongs_to :programmer  # foreign key - programmer_id</td></tr><tr><td id="L412" class="nb">412</td><td>      #     belongs_to :project     # foreign key - project_id</td></tr><tr><td id="L413" class="nb">413</td><td>      #   end</td></tr><tr><td id="L414" class="nb">414</td><td>      #   class Programmer &lt; ActiveRecord::Base</td></tr><tr><td id="L415" class="nb">415</td><td>      #     has_many :assignments</td></tr><tr><td id="L416" class="nb">416</td><td>      #     has_many :projects, through: :assignments</td></tr><tr><td id="L417" class="nb">417</td><td>      #   end</td></tr><tr><td id="L418" class="nb">418</td><td>      #   class Project &lt; ActiveRecord::Base</td></tr><tr><td id="L419" class="nb">419</td><td>      #     has_many :assignments</td></tr><tr><td id="L420" class="nb">420</td><td>      #     has_many :programmers, through: :assignments</td></tr><tr><td id="L421" class="nb">421</td><td>      #   end</td></tr><tr><td id="L422" class="nb">422</td><td>      #</td></tr><tr><td id="L423" class="nb">423</td><td>      # For the second way, use #has_and_belongs_to_many in both models. This requires a join table</td></tr><tr><td id="L424" class="nb">424</td><td>      # that has no corresponding model or primary key.</td></tr><tr><td id="L425" class="nb">425</td><td>      #</td></tr><tr><td id="L426" class="nb">426</td><td>      #   class Programmer &lt; ActiveRecord::Base</td></tr><tr><td id="L427" class="nb">427</td><td>      #     has_and_belongs_to_many :projects       # foreign keys in the join table</td></tr><tr><td id="L428" class="nb">428</td><td>      #   end</td></tr><tr><td id="L429" class="nb">429</td><td>      #   class Project &lt; ActiveRecord::Base</td></tr><tr><td id="L430" class="nb">430</td><td>      #     has_and_belongs_to_many :programmers    # foreign keys in the join table</td></tr><tr><td id="L431" class="nb">431</td><td>      #   end</td></tr><tr><td id="L432" class="nb">432</td><td>      #</td></tr><tr><td id="L433" class="nb">433</td><td>      # Choosing which way to build a many-to-many relationship is not always simple.</td></tr><tr><td id="L434" class="nb">434</td><td>      # If you need to work with the relationship model as its own entity,</td></tr><tr><td id="L435" class="nb">435</td><td>      # use #has_many &lt;tt&gt;:through&lt;/tt&gt;. Use #has_and_belongs_to_many when working with legacy schemas or when</td></tr><tr><td id="L436" class="nb">436</td><td>      # you never work directly with the relationship itself.</td></tr><tr><td id="L437" class="nb">437</td><td>      #</td></tr><tr><td id="L438" class="nb">438</td><td>      # == Is it a #belongs_to or #has_one association?</td></tr><tr><td id="L439" class="nb">439</td><td>      #</td></tr><tr><td id="L440" class="nb">440</td><td>      # Both express a 1-1 relationship. The difference is mostly where to place the foreign</td></tr><tr><td id="L441" class="nb">441</td><td>      # key, which goes on the table for the class declaring the #belongs_to relationship.</td></tr><tr><td id="L442" class="nb">442</td><td>      #</td></tr><tr><td id="L443" class="nb">443</td><td>      #   class User &lt; ActiveRecord::Base</td></tr><tr><td id="L444" class="nb">444</td><td>      #     # I reference an account.</td></tr><tr><td id="L445" class="nb">445</td><td>      #     belongs_to :account</td></tr><tr><td id="L446" class="nb">446</td><td>      #   end</td></tr><tr><td id="L447" class="nb">447</td><td>      #</td></tr><tr><td id="L448" class="nb">448</td><td>      #   class Account &lt; ActiveRecord::Base</td></tr><tr><td id="L449" class="nb">449</td><td>      #     # One user references me.</td></tr><tr><td id="L450" class="nb">450</td><td>      #     has_one :user</td></tr><tr><td id="L451" class="nb">451</td><td>      #   end</td></tr><tr><td id="L452" class="nb">452</td><td>      #</td></tr><tr><td id="L453" class="nb">453</td><td>      # The tables for these classes could look something like:</td></tr><tr><td id="L454" class="nb">454</td><td>      #</td></tr><tr><td id="L455" class="nb">455</td><td>      #   CREATE TABLE users (</td></tr><tr><td id="L456" class="nb">456</td><td>      #     id bigint NOT NULL auto_increment,</td></tr><tr><td id="L457" class="nb">457</td><td>      #     account_id bigint default NULL,</td></tr><tr><td id="L458" class="nb">458</td><td>      #     name varchar default NULL,</td></tr><tr><td id="L459" class="nb">459</td><td>      #     PRIMARY KEY  (id)</td></tr><tr><td id="L460" class="nb">460</td><td>      #   )</td></tr><tr><td id="L461" class="nb">461</td><td>      #</td></tr><tr><td id="L462" class="nb">462</td><td>      #   CREATE TABLE accounts (</td></tr><tr><td id="L463" class="nb">463</td><td>      #     id bigint NOT NULL auto_increment,</td></tr><tr><td id="L464" class="nb">464</td><td>      #     name varchar default NULL,</td></tr><tr><td id="L465" class="nb">465</td><td>      #     PRIMARY KEY  (id)</td></tr><tr><td id="L466" class="nb">466</td><td>      #   )</td></tr><tr><td id="L467" class="nb">467</td><td>      #</td></tr><tr><td id="L468" class="nb">468</td><td>      # == Unsaved objects and associations</td></tr><tr><td id="L469" class="nb">469</td><td>      #</td></tr><tr><td id="L470" class="nb">470</td><td>      # You can manipulate objects and associations before they are saved to the database, but</td></tr><tr><td id="L471" class="nb">471</td><td>      # there is some special behavior you should be aware of, mostly involving the saving of</td></tr><tr><td id="L472" class="nb">472</td><td>      # associated objects.</td></tr><tr><td id="L473" class="nb">473</td><td>      #</td></tr><tr><td id="L474" class="nb">474</td><td>      # You can set the &lt;tt&gt;:autosave&lt;/tt&gt; option on a #has_one, #belongs_to,</td></tr><tr><td id="L475" class="nb">475</td><td>      # #has_many, or #has_and_belongs_to_many association. Setting it</td></tr><tr><td id="L476" class="nb">476</td><td>      # to +true+ will _always_ save the members, whereas setting it to +false+ will</td></tr><tr><td id="L477" class="nb">477</td><td>      # _never_ save the members. More details about &lt;tt&gt;:autosave&lt;/tt&gt; option is available at</td></tr><tr><td id="L478" class="nb">478</td><td>      # AutosaveAssociation.</td></tr><tr><td id="L479" class="nb">479</td><td>      #</td></tr><tr><td id="L480" class="nb">480</td><td>      # === One-to-one associations</td></tr><tr><td id="L481" class="nb">481</td><td>      #</td></tr><tr><td id="L482" class="nb">482</td><td>      # * Assigning an object to a #has_one association automatically saves that object and</td></tr><tr><td id="L483" class="nb">483</td><td>      #   the object being replaced (if there is one), in order to update their foreign</td></tr><tr><td id="L484" class="nb">484</td><td>      #   keys - except if the parent object is unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;).</td></tr><tr><td id="L485" class="nb">485</td><td>      # * If either of these saves fail (due to one of the objects being invalid), an</td></tr><tr><td id="L486" class="nb">486</td><td>      #   ActiveRecord::RecordNotSaved exception is raised and the assignment is</td></tr><tr><td id="L487" class="nb">487</td><td>      #   cancelled.</td></tr><tr><td id="L488" class="nb">488</td><td>      # * If you wish to assign an object to a #has_one association without saving it,</td></tr><tr><td id="L489" class="nb">489</td><td>      #   use the &lt;tt&gt;#build_association&lt;/tt&gt; method (documented below). The object being</td></tr><tr><td id="L490" class="nb">490</td><td>      #   replaced will still be saved to update its foreign key.</td></tr><tr><td id="L491" class="nb">491</td><td>      # * Assigning an object to a #belongs_to association does not save the object, since</td></tr><tr><td id="L492" class="nb">492</td><td>      #   the foreign key field belongs on the parent. It does not save the parent either.</td></tr><tr><td id="L493" class="nb">493</td><td>      #</td></tr><tr><td id="L494" class="nb">494</td><td>      # === Collections</td></tr><tr><td id="L495" class="nb">495</td><td>      #</td></tr><tr><td id="L496" class="nb">496</td><td>      # * Adding an object to a collection (#has_many or #has_and_belongs_to_many) automatically</td></tr><tr><td id="L497" class="nb">497</td><td>      #   saves that object, except if the parent object (the owner of the collection) is not yet</td></tr><tr><td id="L498" class="nb">498</td><td>      #   stored in the database.</td></tr><tr><td id="L499" class="nb">499</td><td>      # * If saving any of the objects being added to a collection (via &lt;tt&gt;push&lt;/tt&gt; or similar)</td></tr><tr><td id="L500" class="nb">500</td><td>      #   fails, then &lt;tt&gt;push&lt;/tt&gt; returns +false+.</td></tr><tr><td id="L501" class="nb">501</td><td>      # * If saving fails while replacing the collection (via &lt;tt&gt;association=&lt;/tt&gt;), an</td></tr><tr><td id="L502" class="nb">502</td><td>      #   ActiveRecord::RecordNotSaved exception is raised and the assignment is</td></tr><tr><td id="L503" class="nb">503</td><td>      #   cancelled.</td></tr><tr><td id="L504" class="nb">504</td><td>      # * You can add an object to a collection without automatically saving it by using the</td></tr><tr><td id="L505" class="nb">505</td><td>      #   &lt;tt&gt;collection.build&lt;/tt&gt; method (documented below).</td></tr><tr><td id="L506" class="nb">506</td><td>      # * All unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;) members of the collection are automatically</td></tr><tr><td id="L507" class="nb">507</td><td>      #   saved when the parent is saved.</td></tr><tr><td id="L508" class="nb">508</td><td>      #</td></tr><tr><td id="L509" class="nb">509</td><td>      # == Customizing the query</td></tr><tr><td id="L510" class="nb">510</td><td>      #</td></tr><tr><td id="L511" class="nb">511</td><td>      # \Associations are built from &lt;tt&gt;Relation&lt;/tt&gt; objects, and you can use the Relation syntax</td></tr><tr><td id="L512" class="nb">512</td><td>      # to customize them. For example, to add a condition:</td></tr><tr><td id="L513" class="nb">513</td><td>      #</td></tr><tr><td id="L514" class="nb">514</td><td>      #   class Blog &lt; ActiveRecord::Base</td></tr><tr><td id="L515" class="nb">515</td><td>      #     has_many :published_posts, -&gt; { where(published: true) }, class_name: 'Post'</td></tr><tr><td id="L516" class="nb">516</td><td>      #   end</td></tr><tr><td id="L517" class="nb">517</td><td>      #</td></tr><tr><td id="L518" class="nb">518</td><td>      # Inside the &lt;tt&gt;-&gt; { ... }&lt;/tt&gt; block you can use all of the usual Relation methods.</td></tr><tr><td id="L519" class="nb">519</td><td>      #</td></tr><tr><td id="L520" class="nb">520</td><td>      # === Accessing the owner object</td></tr><tr><td id="L521" class="nb">521</td><td>      #</td></tr><tr><td id="L522" class="nb">522</td><td>      # Sometimes it is useful to have access to the owner object when building the query. The owner</td></tr><tr><td id="L523" class="nb">523</td><td>      # is passed as a parameter to the block. For example, the following association would find all</td></tr><tr><td id="L524" class="nb">524</td><td>      # events that occur on the user's birthday:</td></tr><tr><td id="L525" class="nb">525</td><td>      #</td></tr><tr><td id="L526" class="nb">526</td><td>      #   class User &lt; ActiveRecord::Base</td></tr><tr><td id="L527" class="nb">527</td><td>      #     has_many :birthday_events, -&gt;(user) { where(starts_on: user.birthday) }, class_name: 'Event'</td></tr><tr><td id="L528" class="nb">528</td><td>      #   end</td></tr><tr><td id="L529" class="nb">529</td><td>      #</td></tr><tr><td id="L530" class="nb">530</td><td>      # Note: Joining, eager loading and preloading of these associations is not possible.</td></tr><tr><td id="L531" class="nb">531</td><td>      # These operations happen before instance creation and the scope will be called with a +nil+ argument.</td></tr><tr><td id="L532" class="nb">532</td><td>      #</td></tr><tr><td id="L533" class="nb">533</td><td>      # == Association callbacks</td></tr><tr><td id="L534" class="nb">534</td><td>      #</td></tr><tr><td id="L535" class="nb">535</td><td>      # Similar to the normal callbacks that hook into the life cycle of an Active Record object,</td></tr><tr><td id="L536" class="nb">536</td><td>      # you can also define callbacks that get triggered when you add an object to or remove an</td></tr><tr><td id="L537" class="nb">537</td><td>      # object from an association collection.</td></tr><tr><td id="L538" class="nb">538</td><td>      #</td></tr><tr><td id="L539" class="nb">539</td><td>      #   class Project</td></tr><tr><td id="L540" class="nb">540</td><td>      #     has_and_belongs_to_many :developers, after_add: :evaluate_velocity</td></tr><tr><td id="L541" class="nb">541</td><td>      #</td></tr><tr><td id="L542" class="nb">542</td><td>      #     def evaluate_velocity(developer)</td></tr><tr><td id="L543" class="nb">543</td><td>      #       ...</td></tr><tr><td id="L544" class="nb">544</td><td>      #     end</td></tr><tr><td id="L545" class="nb">545</td><td>      #   end</td></tr><tr><td id="L546" class="nb">546</td><td>      #</td></tr><tr><td id="L547" class="nb">547</td><td>      # It's possible to stack callbacks by passing them as an array. Example:</td></tr><tr><td id="L548" class="nb">548</td><td>      #</td></tr><tr><td id="L549" class="nb">549</td><td>      #   class Project</td></tr><tr><td id="L550" class="nb">550</td><td>      #     has_and_belongs_to_many :developers,</td></tr><tr><td id="L551" class="nb">551</td><td>      #                             after_add: [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]</td></tr><tr><td id="L552" class="nb">552</td><td>      #   end</td></tr><tr><td id="L553" class="nb">553</td><td>      #</td></tr><tr><td id="L554" class="nb">554</td><td>      # Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.</td></tr><tr><td id="L555" class="nb">555</td><td>      #</td></tr><tr><td id="L556" class="nb">556</td><td>      # If any of the +before_add+ callbacks throw an exception, the object will not be</td></tr><tr><td id="L557" class="nb">557</td><td>      # added to the collection.</td></tr><tr><td id="L558" class="nb">558</td><td>      #</td></tr><tr><td id="L559" class="nb">559</td><td>      # Similarly, if any of the +before_remove+ callbacks throw an exception, the object</td></tr><tr><td id="L560" class="nb">560</td><td>      # will not be removed from the collection.</td></tr><tr><td id="L561" class="nb">561</td><td>      #</td></tr><tr><td id="L562" class="nb">562</td><td>      # == Association extensions</td></tr><tr><td id="L563" class="nb">563</td><td>      #</td></tr><tr><td id="L564" class="nb">564</td><td>      # The proxy objects that control the access to associations can be extended through anonymous</td></tr><tr><td id="L565" class="nb">565</td><td>      # modules. This is especially beneficial for adding new finders, creators, and other</td></tr><tr><td id="L566" class="nb">566</td><td>      # factory-type methods that are only used as part of this association.</td></tr><tr><td id="L567" class="nb">567</td><td>      #</td></tr><tr><td id="L568" class="nb">568</td><td>      #   class Account &lt; ActiveRecord::Base</td></tr><tr><td id="L569" class="nb">569</td><td>      #     has_many :people do</td></tr><tr><td id="L570" class="nb">570</td><td>      #       def find_or_create_by_name(name)</td></tr><tr><td id="L571" class="nb">571</td><td>      #         first_name, last_name = name.split(" ", 2)</td></tr><tr><td id="L572" class="nb">572</td><td>      #         find_or_create_by(first_name: first_name, last_name: last_name)</td></tr><tr><td id="L573" class="nb">573</td><td>      #       end</td></tr><tr><td id="L574" class="nb">574</td><td>      #     end</td></tr><tr><td id="L575" class="nb">575</td><td>      #   end</td></tr><tr><td id="L576" class="nb">576</td><td>      #</td></tr><tr><td id="L577" class="nb">577</td><td>      #   person = Account.first.people.find_or_create_by_name("David Heinemeier Hansson")</td></tr><tr><td id="L578" class="nb">578</td><td>      #   person.first_name # =&gt; "David"</td></tr><tr><td id="L579" class="nb">579</td><td>      #   person.last_name  # =&gt; "Heinemeier Hansson"</td></tr><tr><td id="L580" class="nb">580</td><td>      #</td></tr><tr><td id="L581" class="nb">581</td><td>      # If you need to share the same extensions between many associations, you can use a named</td></tr><tr><td id="L582" class="nb">582</td><td>      # extension module.</td></tr><tr><td id="L583" class="nb">583</td><td>      #</td></tr><tr><td id="L584" class="nb">584</td><td>      #   module FindOrCreateByNameExtension</td></tr><tr><td id="L585" class="nb">585</td><td>      #     def find_or_create_by_name(name)</td></tr><tr><td id="L586" class="nb">586</td><td>      #       first_name, last_name = name.split(" ", 2)</td></tr><tr><td id="L587" class="nb">587</td><td>      #       find_or_create_by(first_name: first_name, last_name: last_name)</td></tr><tr><td id="L588" class="nb">588</td><td>      #     end</td></tr><tr><td id="L589" class="nb">589</td><td>      #   end</td></tr><tr><td id="L590" class="nb">590</td><td>      #</td></tr><tr><td id="L591" class="nb">591</td><td>      #   class Account &lt; ActiveRecord::Base</td></tr><tr><td id="L592" class="nb">592</td><td>      #     has_many :people, -&gt; { extending FindOrCreateByNameExtension }</td></tr><tr><td id="L593" class="nb">593</td><td>      #   end</td></tr><tr><td id="L594" class="nb">594</td><td>      #</td></tr><tr><td id="L595" class="nb">595</td><td>      #   class Company &lt; ActiveRecord::Base</td></tr><tr><td id="L596" class="nb">596</td><td>      #     has_many :people, -&gt; { extending FindOrCreateByNameExtension }</td></tr><tr><td id="L597" class="nb">597</td><td>      #   end</td></tr><tr><td id="L598" class="nb">598</td><td>      #</td></tr><tr><td id="L599" class="nb">599</td><td>      # Some extensions can only be made to work with knowledge of the association's internals.</td></tr><tr><td id="L600" class="nb">600</td><td>      # Extensions can access relevant state using the following methods (where +items+ is the</td></tr><tr><td id="L601" class="nb">601</td><td>      # name of the association):</td></tr><tr><td id="L602" class="nb">602</td><td>      #</td></tr><tr><td id="L603" class="nb">603</td><td>      # * &lt;tt&gt;record.association(:items).owner&lt;/tt&gt; - Returns the object the association is part of.</td></tr><tr><td id="L604" class="nb">604</td><td>      # * &lt;tt&gt;record.association(:items).reflection&lt;/tt&gt; - Returns the reflection object that describes the association.</td></tr><tr><td id="L605" class="nb">605</td><td>      # * &lt;tt&gt;record.association(:items).target&lt;/tt&gt; - Returns the associated object for #belongs_to and #has_one, or</td></tr><tr><td id="L606" class="nb">606</td><td>      #   the collection of associated objects for #has_many and #has_and_belongs_to_many.</td></tr><tr><td id="L607" class="nb">607</td><td>      #</td></tr><tr><td id="L608" class="nb">608</td><td>      # However, inside the actual extension code, you will not have access to the &lt;tt&gt;record&lt;/tt&gt; as</td></tr><tr><td id="L609" class="nb">609</td><td>      # above. In this case, you can access &lt;tt&gt;proxy_association&lt;/tt&gt;. For example,</td></tr><tr><td id="L610" class="nb">610</td><td>      # &lt;tt&gt;record.association(:items)&lt;/tt&gt; and &lt;tt&gt;record.items.proxy_association&lt;/tt&gt; will return</td></tr><tr><td id="L611" class="nb">611</td><td>      # the same object, allowing you to make calls like &lt;tt&gt;proxy_association.owner&lt;/tt&gt; inside</td></tr><tr><td id="L612" class="nb">612</td><td>      # association extensions.</td></tr><tr><td id="L613" class="nb">613</td><td>      #</td></tr><tr><td id="L614" class="nb">614</td><td>      # == Association Join Models</td></tr><tr><td id="L615" class="nb">615</td><td>      #</td></tr><tr><td id="L616" class="nb">616</td><td>      # Has Many associations can be configured with the &lt;tt&gt;:through&lt;/tt&gt; option to use an</td></tr><tr><td id="L617" class="nb">617</td><td>      # explicit join model to retrieve the data. This operates similarly to a</td></tr><tr><td id="L618" class="nb">618</td><td>      # #has_and_belongs_to_many association. The advantage is that you're able to add validations,</td></tr><tr><td id="L619" class="nb">619</td><td>      # callbacks, and extra attributes on the join model. Consider the following schema:</td></tr><tr><td id="L620" class="nb">620</td><td>      #</td></tr><tr><td id="L621" class="nb">621</td><td>      #   class Author &lt; ActiveRecord::Base</td></tr><tr><td id="L622" class="nb">622</td><td>      #     has_many :authorships</td></tr><tr><td id="L623" class="nb">623</td><td>      #     has_many :books, through: :authorships</td></tr><tr><td id="L624" class="nb">624</td><td>      #   end</td></tr><tr><td id="L625" class="nb">625</td><td>      #</td></tr><tr><td id="L626" class="nb">626</td><td>      #   class Authorship &lt; ActiveRecord::Base</td></tr><tr><td id="L627" class="nb">627</td><td>      #     belongs_to :author</td></tr><tr><td id="L628" class="nb">628</td><td>      #     belongs_to :book</td></tr><tr><td id="L629" class="nb">629</td><td>      #   end</td></tr><tr><td id="L630" class="nb">630</td><td>      #</td></tr><tr><td id="L631" class="nb">631</td><td>      #   @author = Author.first</td></tr><tr><td id="L632" class="nb">632</td><td>      #   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to</td></tr><tr><td id="L633" class="nb">633</td><td>      #   @author.books                              # selects all books by using the Authorship join model</td></tr><tr><td id="L634" class="nb">634</td><td>      #</td></tr><tr><td id="L635" class="nb">635</td><td>      # You can also go through a #has_many association on the join model:</td></tr><tr><td id="L636" class="nb">636</td><td>      #</td></tr><tr><td id="L637" class="nb">637</td><td>      #   class Firm &lt; ActiveRecord::Base</td></tr><tr><td id="L638" class="nb">638</td><td>      #     has_many   :clients</td></tr><tr><td id="L639" class="nb">639</td><td>      #     has_many   :invoices, through: :clients</td></tr><tr><td id="L640" class="nb">640</td><td>      #   end</td></tr><tr><td id="L641" class="nb">641</td><td>      #</td></tr><tr><td id="L642" class="nb">642</td><td>      #   class Client &lt; ActiveRecord::Base</td></tr><tr><td id="L643" class="nb">643</td><td>      #     belongs_to :firm</td></tr><tr><td id="L644" class="nb">644</td><td>      #     has_many   :invoices</td></tr><tr><td id="L645" class="nb">645</td><td>      #   end</td></tr><tr><td id="L646" class="nb">646</td><td>      #</td></tr><tr><td id="L647" class="nb">647</td><td>      #   class Invoice &lt; ActiveRecord::Base</td></tr><tr><td id="L648" class="nb">648</td><td>      #     belongs_to :client</td></tr><tr><td id="L649" class="nb">649</td><td>      #   end</td></tr><tr><td id="L650" class="nb">650</td><td>      #</td></tr><tr><td id="L651" class="nb">651</td><td>      #   @firm = Firm.first</td></tr><tr><td id="L652" class="nb">652</td><td>      #   @firm.clients.flat_map { |c| c.invoices } # select all invoices for all clients of the firm</td></tr><tr><td id="L653" class="nb">653</td><td>      #   @firm.invoices                            # selects all invoices by going through the Client join model</td></tr><tr><td id="L654" class="nb">654</td><td>      #</td></tr><tr><td id="L655" class="nb">655</td><td>      # Similarly you can go through a #has_one association on the join model:</td></tr><tr><td id="L656" class="nb">656</td><td>      #</td></tr><tr><td id="L657" class="nb">657</td><td>      #   class Group &lt; ActiveRecord::Base</td></tr><tr><td id="L658" class="nb">658</td><td>      #     has_many   :users</td></tr><tr><td id="L659" class="nb">659</td><td>      #     has_many   :avatars, through: :users</td></tr><tr><td id="L660" class="nb">660</td><td>      #   end</td></tr><tr><td id="L661" class="nb">661</td><td>      #</td></tr><tr><td id="L662" class="nb">662</td><td>      #   class User &lt; ActiveRecord::Base</td></tr><tr><td id="L663" class="nb">663</td><td>      #     belongs_to :group</td></tr><tr><td id="L664" class="nb">664</td><td>      #     has_one    :avatar</td></tr><tr><td id="L665" class="nb">665</td><td>      #   end</td></tr><tr><td id="L666" class="nb">666</td><td>      #</td></tr><tr><td id="L667" class="nb">667</td><td>      #   class Avatar &lt; ActiveRecord::Base</td></tr><tr><td id="L668" class="nb">668</td><td>      #     belongs_to :user</td></tr><tr><td id="L669" class="nb">669</td><td>      #   end</td></tr><tr><td id="L670" class="nb">670</td><td>      #</td></tr><tr><td id="L671" class="nb">671</td><td>      #   @group = Group.first</td></tr><tr><td id="L672" class="nb">672</td><td>      #   @group.users.collect { |u| u.avatar }.compact # select all avatars for all users in the group</td></tr><tr><td id="L673" class="nb">673</td><td>      #   @group.avatars                                # selects all avatars by going through the User join model.</td></tr><tr><td id="L674" class="nb">674</td><td>      #</td></tr><tr><td id="L675" class="nb">675</td><td>      # An important caveat with going through #has_one or #has_many associations on the</td></tr><tr><td id="L676" class="nb">676</td><td>      # join model is that these associations are *read-only*. For example, the following</td></tr><tr><td id="L677" class="nb">677</td><td>      # would not work following the previous example:</td></tr><tr><td id="L678" class="nb">678</td><td>      #</td></tr><tr><td id="L679" class="nb">679</td><td>      #   @group.avatars &lt;&lt; Avatar.new   # this would work if User belonged_to Avatar rather than the other way around</td></tr><tr><td id="L680" class="nb">680</td><td>      #   @group.avatars.delete(@group.avatars.last)  # so would this</td></tr><tr><td id="L681" class="nb">681</td><td>      #</td></tr><tr><td id="L682" class="nb">682</td><td>      # == Setting Inverses</td></tr><tr><td id="L683" class="nb">683</td><td>      #</td></tr><tr><td id="L684" class="nb">684</td><td>      # If you are using a #belongs_to on the join model, it is a good idea to set the</td></tr><tr><td id="L685" class="nb">685</td><td>      # &lt;tt&gt;:inverse_of&lt;/tt&gt; option on the #belongs_to, which will mean that the following example</td></tr><tr><td id="L686" class="nb">686</td><td>      # works correctly (where &lt;tt&gt;tags&lt;/tt&gt; is a #has_many &lt;tt&gt;:through&lt;/tt&gt; association):</td></tr><tr><td id="L687" class="nb">687</td><td>      #</td></tr><tr><td id="L688" class="nb">688</td><td>      #   @post = Post.first</td></tr><tr><td id="L689" class="nb">689</td><td>      #   @tag = @post.tags.build name: "ruby"</td></tr><tr><td id="L690" class="nb">690</td><td>      #   @tag.save</td></tr><tr><td id="L691" class="nb">691</td><td>      #</td></tr><tr><td id="L692" class="nb">692</td><td>      # The last line ought to save the through record (a &lt;tt&gt;Tagging&lt;/tt&gt;). This will only work if the</td></tr><tr><td id="L693" class="nb">693</td><td>      # &lt;tt&gt;:inverse_of&lt;/tt&gt; is set:</td></tr><tr><td id="L694" class="nb">694</td><td>      #</td></tr><tr><td id="L695" class="nb">695</td><td>      #   class Tagging &lt; ActiveRecord::Base</td></tr><tr><td id="L696" class="nb">696</td><td>      #     belongs_to :post</td></tr><tr><td id="L697" class="nb">697</td><td>      #     belongs_to :tag, inverse_of: :taggings</td></tr><tr><td id="L698" class="nb">698</td><td>      #   end</td></tr><tr><td id="L699" class="nb">699</td><td>      #</td></tr><tr><td id="L700" class="nb">700</td><td>      # If you do not set the &lt;tt&gt;:inverse_of&lt;/tt&gt; record, the association will</td></tr><tr><td id="L701" class="nb">701</td><td>      # do its best to match itself up with the correct inverse. Automatic</td></tr><tr><td id="L702" class="nb">702</td><td>      # inverse detection only works on #has_many, #has_one, and</td></tr><tr><td id="L703" class="nb">703</td><td>      # #belongs_to associations.</td></tr><tr><td id="L704" class="nb">704</td><td>      #</td></tr><tr><td id="L705" class="nb">705</td><td>      # Extra options on the associations, as defined in the</td></tr><tr><td id="L706" class="nb">706</td><td>      # &lt;tt&gt;AssociationReflection::INVALID_AUTOMATIC_INVERSE_OPTIONS&lt;/tt&gt; constant, will</td></tr><tr><td id="L707" class="nb">707</td><td>      # also prevent the association's inverse from being found automatically.</td></tr><tr><td id="L708" class="nb">708</td><td>      #</td></tr><tr><td id="L709" class="nb">709</td><td>      # The automatic guessing of the inverse association uses a heuristic based</td></tr><tr><td id="L710" class="nb">710</td><td>      # on the name of the class, so it may not work for all associations,</td></tr><tr><td id="L711" class="nb">711</td><td>      # especially the ones with non-standard names.</td></tr><tr><td id="L712" class="nb">712</td><td>      #</td></tr><tr><td id="L713" class="nb">713</td><td>      # You can turn off the automatic detection of inverse associations by setting</td></tr><tr><td id="L714" class="nb">714</td><td>      # the &lt;tt&gt;:inverse_of&lt;/tt&gt; option to &lt;tt&gt;false&lt;/tt&gt; like so:</td></tr><tr><td id="L715" class="nb">715</td><td>      #</td></tr><tr><td id="L716" class="nb">716</td><td>      #   class Tagging &lt; ActiveRecord::Base</td></tr><tr><td id="L717" class="nb">717</td><td>      #     belongs_to :tag, inverse_of: false</td></tr><tr><td id="L718" class="nb">718</td><td>      #   end</td></tr><tr><td id="L719" class="nb">719</td><td>      #</td></tr><tr><td id="L720" class="nb">720</td><td>      # == Nested \Associations</td></tr><tr><td id="L721" class="nb">721</td><td>      #</td></tr><tr><td id="L722" class="nb">722</td><td>      # You can actually specify *any* association with the &lt;tt&gt;:through&lt;/tt&gt; option, including an</td></tr><tr><td id="L723" class="nb">723</td><td>      # association which has a &lt;tt&gt;:through&lt;/tt&gt; option itself. For example:</td></tr><tr><td id="L724" class="nb">724</td><td>      #</td></tr><tr><td id="L725" class="nb">725</td><td>      #   class Author &lt; ActiveRecord::Base</td></tr><tr><td id="L726" class="nb">726</td><td>      #     has_many :posts</td></tr><tr><td id="L727" class="nb">727</td><td>      #     has_many :comments, through: :posts</td></tr><tr><td id="L728" class="nb">728</td><td>      #     has_many :commenters, through: :comments</td></tr><tr><td id="L729" class="nb">729</td><td>      #   end</td></tr><tr><td id="L730" class="nb">730</td><td>      #</td></tr><tr><td id="L731" class="nb">731</td><td>      #   class Post &lt; ActiveRecord::Base</td></tr><tr><td id="L732" class="nb">732</td><td>      #     has_many :comments</td></tr><tr><td id="L733" class="nb">733</td><td>      #   end</td></tr><tr><td id="L734" class="nb">734</td><td>      #</td></tr><tr><td id="L735" class="nb">735</td><td>      #   class Comment &lt; ActiveRecord::Base</td></tr><tr><td id="L736" class="nb">736</td><td>      #     belongs_to :commenter</td></tr><tr><td id="L737" class="nb">737</td><td>      #   end</td></tr><tr><td id="L738" class="nb">738</td><td>      #</td></tr><tr><td id="L739" class="nb">739</td><td>      #   @author = Author.first</td></tr><tr><td id="L740" class="nb">740</td><td>      #   @author.commenters # =&gt; People who commented on posts written by the author</td></tr><tr><td id="L741" class="nb">741</td><td>      #</td></tr><tr><td id="L742" class="nb">742</td><td>      # An equivalent way of setting up this association this would be:</td></tr><tr><td id="L743" class="nb">743</td><td>      #</td></tr><tr><td id="L744" class="nb">744</td><td>      #   class Author &lt; ActiveRecord::Base</td></tr><tr><td id="L745" class="nb">745</td><td>      #     has_many :posts</td></tr><tr><td id="L746" class="nb">746</td><td>      #     has_many :commenters, through: :posts</td></tr><tr><td id="L747" class="nb">747</td><td>      #   end</td></tr><tr><td id="L748" class="nb">748</td><td>      #</td></tr><tr><td id="L749" class="nb">749</td><td>      #   class Post &lt; ActiveRecord::Base</td></tr><tr><td id="L750" class="nb">750</td><td>      #     has_many :comments</td></tr><tr><td id="L751" class="nb">751</td><td>      #     has_many :commenters, through: :comments</td></tr><tr><td id="L752" class="nb">752</td><td>      #   end</td></tr><tr><td id="L753" class="nb">753</td><td>      #</td></tr><tr><td id="L754" class="nb">754</td><td>      #   class Comment &lt; ActiveRecord::Base</td></tr><tr><td id="L755" class="nb">755</td><td>      #     belongs_to :commenter</td></tr><tr><td id="L756" class="nb">756</td><td>      #   end</td></tr><tr><td id="L757" class="nb">757</td><td>      #</td></tr><tr><td id="L758" class="nb">758</td><td>      # When using a nested association, you will not be able to modify the association because there</td></tr><tr><td id="L759" class="nb">759</td><td>      # is not enough information to know what modification to make. For example, if you tried to</td></tr><tr><td id="L760" class="nb">760</td><td>      # add a &lt;tt&gt;Commenter&lt;/tt&gt; in the example above, there would be no way to tell how to set up the</td></tr><tr><td id="L761" class="nb">761</td><td>      # intermediate &lt;tt&gt;Post&lt;/tt&gt; and &lt;tt&gt;Comment&lt;/tt&gt; objects.</td></tr><tr><td id="L762" class="nb">762</td><td>      #</td></tr><tr><td id="L763" class="nb">763</td><td>      # == Polymorphic \Associations</td></tr><tr><td id="L764" class="nb">764</td><td>      #</td></tr><tr><td id="L765" class="nb">765</td><td>      # Polymorphic associations on models are not restricted on what types of models they</td></tr><tr><td id="L766" class="nb">766</td><td>      # can be associated with. Rather, they specify an interface that a #has_many association</td></tr><tr><td id="L767" class="nb">767</td><td>      # must adhere to.</td></tr><tr><td id="L768" class="nb">768</td><td>      #</td></tr><tr><td id="L769" class="nb">769</td><td>      #   class Asset &lt; ActiveRecord::Base</td></tr><tr><td id="L770" class="nb">770</td><td>      #     belongs_to :attachable, polymorphic: true</td></tr><tr><td id="L771" class="nb">771</td><td>      #   end</td></tr><tr><td id="L772" class="nb">772</td><td>      #</td></tr><tr><td id="L773" class="nb">773</td><td>      #   class Post &lt; ActiveRecord::Base</td></tr><tr><td id="L774" class="nb">774</td><td>      #     has_many :assets, as: :attachable         # The :as option specifies the polymorphic interface to use.</td></tr><tr><td id="L775" class="nb">775</td><td>      #   end</td></tr><tr><td id="L776" class="nb">776</td><td>      #</td></tr><tr><td id="L777" class="nb">777</td><td>      #   @asset.attachable = @post</td></tr><tr><td id="L778" class="nb">778</td><td>      #</td></tr><tr><td id="L779" class="nb">779</td><td>      # This works by using a type column in addition to a foreign key to specify the associated</td></tr><tr><td id="L780" class="nb">780</td><td>      # record. In the Asset example, you'd need an +attachable_id+ integer column and an</td></tr><tr><td id="L781" class="nb">781</td><td>      # +attachable_type+ string column.</td></tr><tr><td id="L782" class="nb">782</td><td>      #</td></tr><tr><td id="L783" class="nb">783</td><td>      # Using polymorphic associations in combination with single table inheritance (STI) is</td></tr><tr><td id="L784" class="nb">784</td><td>      # a little tricky. In order for the associations to work as expected, ensure that you</td></tr><tr><td id="L785" class="nb">785</td><td>      # store the base model for the STI models in the type column of the polymorphic</td></tr><tr><td id="L786" class="nb">786</td><td>      # association. To continue with the asset example above, suppose there are guest posts</td></tr><tr><td id="L787" class="nb">787</td><td>      # and member posts that use the posts table for STI. In this case, there must be a +type+</td></tr><tr><td id="L788" class="nb">788</td><td>      # column in the posts table.</td></tr><tr><td id="L789" class="nb">789</td><td>      #</td></tr><tr><td id="L790" class="nb">790</td><td>      # Note: The &lt;tt&gt;attachable_type=&lt;/tt&gt; method is being called when assigning an +attachable+.</td></tr><tr><td id="L791" class="nb">791</td><td>      # The +class_name+ of the +attachable+ is passed as a String.</td></tr><tr><td id="L792" class="nb">792</td><td>      #</td></tr><tr><td id="L793" class="nb">793</td><td>      #   class Asset &lt; ActiveRecord::Base</td></tr><tr><td id="L794" class="nb">794</td><td>      #     belongs_to :attachable, polymorphic: true</td></tr><tr><td id="L795" class="nb">795</td><td>      #</td></tr><tr><td id="L796" class="nb">796</td><td>      #     def attachable_type=(class_name)</td></tr><tr><td id="L797" class="nb">797</td><td>      #        super(class_name.constantize.base_class.to_s)</td></tr><tr><td id="L798" class="nb">798</td><td>      #     end</td></tr><tr><td id="L799" class="nb">799</td><td>      #   end</td></tr><tr><td id="L800" class="nb">800</td><td>      #</td></tr><tr><td id="L801" class="nb">801</td><td>      #   class Post &lt; ActiveRecord::Base</td></tr><tr><td id="L802" class="nb">802</td><td>      #     # because we store "Post" in attachable_type now dependent: :destroy will work</td></tr><tr><td id="L803" class="nb">803</td><td>      #     has_many :assets, as: :attachable, dependent: :destroy</td></tr><tr><td id="L804" class="nb">804</td><td>      #   end</td></tr><tr><td id="L805" class="nb">805</td><td>      #</td></tr><tr><td id="L806" class="nb">806</td><td>      #   class GuestPost &lt; Post</td></tr><tr><td id="L807" class="nb">807</td><td>      #   end</td></tr><tr><td id="L808" class="nb">808</td><td>      #</td></tr><tr><td id="L809" class="nb">809</td><td>      #   class MemberPost &lt; Post</td></tr><tr><td id="L810" class="nb">810</td><td>      #   end</td></tr><tr><td id="L811" class="nb">811</td><td>      #</td></tr><tr><td id="L812" class="nb">812</td><td>      # == Caching</td></tr><tr><td id="L813" class="nb">813</td><td>      #</td></tr><tr><td id="L814" class="nb">814</td><td>      # All of the methods are built on a simple caching principle that will keep the result</td></tr><tr><td id="L815" class="nb">815</td><td>      # of the last query around unless specifically instructed not to. The cache is even</td></tr><tr><td id="L816" class="nb">816</td><td>      # shared across methods to make it even cheaper to use the macro-added methods without</td></tr><tr><td id="L817" class="nb">817</td><td>      # worrying too much about performance at the first go.</td></tr><tr><td id="L818" class="nb">818</td><td>      #</td></tr><tr><td id="L819" class="nb">819</td><td>      #   project.milestones             # fetches milestones from the database</td></tr><tr><td id="L820" class="nb">820</td><td>      #   project.milestones.size        # uses the milestone cache</td></tr><tr><td id="L821" class="nb">821</td><td>      #   project.milestones.empty?      # uses the milestone cache</td></tr><tr><td id="L822" class="nb">822</td><td>      #   project.milestones.reload.size # fetches milestones from the database</td></tr><tr><td id="L823" class="nb">823</td><td>      #   project.milestones             # uses the milestone cache</td></tr><tr><td id="L824" class="nb">824</td><td>      #</td></tr><tr><td id="L825" class="nb">825</td><td>      # == Eager loading of associations</td></tr><tr><td id="L826" class="nb">826</td><td>      #</td></tr><tr><td id="L827" class="nb">827</td><td>      # Eager loading is a way to find objects of a certain class and a number of named associations.</td></tr><tr><td id="L828" class="nb">828</td><td>      # It is one of the easiest ways to prevent the dreaded N+1 problem in which fetching 100</td></tr><tr><td id="L829" class="nb">829</td><td>      # posts that each need to display their author triggers 101 database queries. Through the</td></tr><tr><td id="L830" class="nb">830</td><td>      # use of eager loading, the number of queries will be reduced from 101 to 2.</td></tr><tr><td id="L831" class="nb">831</td><td>      #</td></tr><tr><td id="L832" class="nb">832</td><td>      #   class Post &lt; ActiveRecord::Base</td></tr><tr><td id="L833" class="nb">833</td><td>      #     belongs_to :author</td></tr><tr><td id="L834" class="nb">834</td><td>      #     has_many   :comments</td></tr><tr><td id="L835" class="nb">835</td><td>      #   end</td></tr><tr><td id="L836" class="nb">836</td><td>      #</td></tr><tr><td id="L837" class="nb">837</td><td>      # Consider the following loop using the class above:</td></tr><tr><td id="L838" class="nb">838</td><td>      #</td></tr><tr><td id="L839" class="nb">839</td><td>      #   Post.all.each do |post|</td></tr><tr><td id="L840" class="nb">840</td><td>      #     puts "Post:            " + post.title</td></tr><tr><td id="L841" class="nb">841</td><td>      #     puts "Written by:      " + post.author.name</td></tr><tr><td id="L842" class="nb">842</td><td>      #     puts "Last comment on: " + post.comments.first.created_on</td></tr><tr><td id="L843" class="nb">843</td><td>      #   end</td></tr><tr><td id="L844" class="nb">844</td><td>      #</td></tr><tr><td id="L845" class="nb">845</td><td>      # To iterate over these one hundred posts, we'll generate 201 database queries. Let's</td></tr><tr><td id="L846" class="nb">846</td><td>      # first just optimize it for retrieving the author:</td></tr><tr><td id="L847" class="nb">847</td><td>      #</td></tr><tr><td id="L848" class="nb">848</td><td>      #   Post.includes(:author).each do |post|</td></tr><tr><td id="L849" class="nb">849</td><td>      #</td></tr><tr><td id="L850" class="nb">850</td><td>      # This references the name of the #belongs_to association that also used the &lt;tt&gt;:author&lt;/tt&gt;</td></tr><tr><td id="L851" class="nb">851</td><td>      # symbol. After loading the posts, +find+ will collect the +author_id+ from each one and load</td></tr><tr><td id="L852" class="nb">852</td><td>      # all of the referenced authors with one query. Doing so will cut down the number of queries</td></tr><tr><td id="L853" class="nb">853</td><td>      # from 201 to 102.</td></tr><tr><td id="L854" class="nb">854</td><td>      #</td></tr><tr><td id="L855" class="nb">855</td><td>      # We can improve upon the situation further by referencing both associations in the finder with:</td></tr><tr><td id="L856" class="nb">856</td><td>      #</td></tr><tr><td id="L857" class="nb">857</td><td>      #   Post.includes(:author, :comments).each do |post|</td></tr><tr><td id="L858" class="nb">858</td><td>      #</td></tr><tr><td id="L859" class="nb">859</td><td>      # This will load all comments with a single query. This reduces the total number of queries</td></tr><tr><td id="L860" class="nb">860</td><td>      # to 3. In general, the number of queries will be 1 plus the number of associations</td></tr><tr><td id="L861" class="nb">861</td><td>      # named (except if some of the associations are polymorphic #belongs_to - see below).</td></tr><tr><td id="L862" class="nb">862</td><td>      #</td></tr><tr><td id="L863" class="nb">863</td><td>      # To include a deep hierarchy of associations, use a hash:</td></tr><tr><td id="L864" class="nb">864</td><td>      #</td></tr><tr><td id="L865" class="nb">865</td><td>      #   Post.includes(:author, { comments: { author: :gravatar } }).each do |post|</td></tr><tr><td id="L866" class="nb">866</td><td>      #</td></tr><tr><td id="L867" class="nb">867</td><td>      # The above code will load all the comments and all of their associated</td></tr><tr><td id="L868" class="nb">868</td><td>      # authors and gravatars. You can mix and match any combination of symbols,</td></tr><tr><td id="L869" class="nb">869</td><td>      # arrays, and hashes to retrieve the associations you want to load.</td></tr><tr><td id="L870" class="nb">870</td><td>      #</td></tr><tr><td id="L871" class="nb">871</td><td>      # All of this power shouldn't fool you into thinking that you can pull out huge amounts</td></tr><tr><td id="L872" class="nb">872</td><td>      # of data with no performance penalty just because you've reduced the number of queries.</td></tr><tr><td id="L873" class="nb">873</td><td>      # The database still needs to send all the data to Active Record and it still needs to</td></tr><tr><td id="L874" class="nb">874</td><td>      # be processed. So it's no catch-all for performance problems, but it's a great way to</td></tr><tr><td id="L875" class="nb">875</td><td>      # cut down on the number of queries in a situation as the one described above.</td></tr><tr><td id="L876" class="nb">876</td><td>      #</td></tr><tr><td id="L877" class="nb">877</td><td>      # Since only one table is loaded at a time, conditions or orders cannot reference tables</td></tr><tr><td id="L878" class="nb">878</td><td>      # other than the main one. If this is the case, Active Record falls back to the previously</td></tr><tr><td id="L879" class="nb">879</td><td>      # used &lt;tt&gt;LEFT OUTER JOIN&lt;/tt&gt; based strategy. For example:</td></tr><tr><td id="L880" class="nb">880</td><td>      #</td></tr><tr><td id="L881" class="nb">881</td><td>      #   Post.includes([:author, :comments]).where(['comments.approved = ?', true])</td></tr><tr><td id="L882" class="nb">882</td><td>      #</td></tr><tr><td id="L883" class="nb">883</td><td>      # This will result in a single SQL query with joins along the lines of:</td></tr><tr><td id="L884" class="nb">884</td><td>      # &lt;tt&gt;LEFT OUTER JOIN comments ON comments.post_id = posts.id&lt;/tt&gt; and</td></tr><tr><td id="L885" class="nb">885</td><td>      # &lt;tt&gt;LEFT OUTER JOIN authors ON authors.id = posts.author_id&lt;/tt&gt;. Note that using conditions</td></tr><tr><td id="L886" class="nb">886</td><td>      # like this can have unintended consequences.</td></tr><tr><td id="L887" class="nb">887</td><td>      # In the above example, posts with no approved comments are not returned at all because</td></tr><tr><td id="L888" class="nb">888</td><td>      # the conditions apply to the SQL statement as a whole and not just to the association.</td></tr><tr><td id="L889" class="nb">889</td><td>      #</td></tr><tr><td id="L890" class="nb">890</td><td>      # You must disambiguate column references for this fallback to happen, for example</td></tr><tr><td id="L891" class="nb">891</td><td>      # &lt;tt&gt;order: "author.name DESC"&lt;/tt&gt; will work but &lt;tt&gt;order: "name DESC"&lt;/tt&gt; will not.</td></tr><tr><td id="L892" class="nb">892</td><td>      #</td></tr><tr><td id="L893" class="nb">893</td><td>      # If you want to load all posts (including posts with no approved comments), then write</td></tr><tr><td id="L894" class="nb">894</td><td>      # your own &lt;tt&gt;LEFT OUTER JOIN&lt;/tt&gt; query using &lt;tt&gt;ON&lt;/tt&gt;:</td></tr><tr><td id="L895" class="nb">895</td><td>      #</td></tr><tr><td id="L896" class="nb">896</td><td>      #   Post.joins("LEFT OUTER JOIN comments ON comments.post_id = posts.id AND comments.approved = '1'")</td></tr><tr><td id="L897" class="nb">897</td><td>      #</td></tr><tr><td id="L898" class="nb">898</td><td>      # In this case, it is usually more natural to include an association which has conditions defined on it:</td></tr><tr><td id="L899" class="nb">899</td><td>      #</td></tr><tr><td id="L900" class="nb">900</td><td>      #   class Post &lt; ActiveRecord::Base</td></tr><tr><td id="L901" class="nb">901</td><td>      #     has_many :approved_comments, -&gt; { where(approved: true) }, class_name: 'Comment'</td></tr><tr><td id="L902" class="nb">902</td><td>      #   end</td></tr><tr><td id="L903" class="nb">903</td><td>      #</td></tr><tr><td id="L904" class="nb">904</td><td>      #   Post.includes(:approved_comments)</td></tr><tr><td id="L905" class="nb">905</td><td>      #</td></tr><tr><td id="L906" class="nb">906</td><td>      # This will load posts and eager load the +approved_comments+ association, which contains</td></tr><tr><td id="L907" class="nb">907</td><td>      # only those comments that have been approved.</td></tr><tr><td id="L908" class="nb">908</td><td>      #</td></tr><tr><td id="L909" class="nb">909</td><td>      # If you eager load an association with a specified &lt;tt&gt;:limit&lt;/tt&gt; option, it will be ignored,</td></tr><tr><td id="L910" class="nb">910</td><td>      # returning all the associated objects:</td></tr><tr><td id="L911" class="nb">911</td><td>      #</td></tr><tr><td id="L912" class="nb">912</td><td>      #   class Picture &lt; ActiveRecord::Base</td></tr><tr><td id="L913" class="nb">913</td><td>      #     has_many :most_recent_comments, -&gt; { order('id DESC').limit(10) }, class_name: 'Comment'</td></tr><tr><td id="L914" class="nb">914</td><td>      #   end</td></tr><tr><td id="L915" class="nb">915</td><td>      #</td></tr><tr><td id="L916" class="nb">916</td><td>      #   Picture.includes(:most_recent_comments).first.most_recent_comments # =&gt; returns all associated comments.</td></tr><tr><td id="L917" class="nb">917</td><td>      #</td></tr><tr><td id="L918" class="nb">918</td><td>      # Eager loading is supported with polymorphic associations.</td></tr><tr><td id="L919" class="nb">919</td><td>      #</td></tr><tr><td id="L920" class="nb">920</td><td>      #   class Address &lt; ActiveRecord::Base</td></tr><tr><td id="L921" class="nb">921</td><td>      #     belongs_to :addressable, polymorphic: true</td></tr><tr><td id="L922" class="nb">922</td><td>      #   end</td></tr><tr><td id="L923" class="nb">923</td><td>      #</td></tr><tr><td id="L924" class="nb">924</td><td>      # A call that tries to eager load the addressable model</td></tr><tr><td id="L925" class="nb">925</td><td>      #</td></tr><tr><td id="L926" class="nb">926</td><td>      #   Address.includes(:addressable)</td></tr><tr><td id="L927" class="nb">927</td><td>      #</td></tr><tr><td id="L928" class="nb">928</td><td>      # This will execute one query to load the addresses and load the addressables with one</td></tr><tr><td id="L929" class="nb">929</td><td>      # query per addressable type.</td></tr><tr><td id="L930" class="nb">930</td><td>      # For example, if all the addressables are either of class Person or Company, then a total</td></tr><tr><td id="L931" class="nb">931</td><td>      # of 3 queries will be executed. The list of addressable types to load is determined on</td></tr><tr><td id="L932" class="nb">932</td><td>      # the back of the addresses loaded. This is not supported if Active Record has to fallback</td></tr><tr><td id="L933" class="nb">933</td><td>      # to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError.</td></tr><tr><td id="L934" class="nb">934</td><td>      # The reason is that the parent model's type is a column value so its corresponding table</td></tr><tr><td id="L935" class="nb">935</td><td>      # name cannot be put in the +FROM+/+JOIN+ clauses of that query.</td></tr><tr><td id="L936" class="nb">936</td><td>      #</td></tr><tr><td id="L937" class="nb">937</td><td>      # == Table Aliasing</td></tr><tr><td id="L938" class="nb">938</td><td>      #</td></tr><tr><td id="L939" class="nb">939</td><td>      # Active Record uses table aliasing in the case that a table is referenced multiple times</td></tr><tr><td id="L940" class="nb">940</td><td>      # in a join. If a table is referenced only once, the standard table name is used. The</td></tr><tr><td id="L941" class="nb">941</td><td>      # second time, the table is aliased as &lt;tt&gt;#{reflection_name}_#{parent_table_name}&lt;/tt&gt;.</td></tr><tr><td id="L942" class="nb">942</td><td>      # Indexes are appended for any more successive uses of the table name.</td></tr><tr><td id="L943" class="nb">943</td><td>      #</td></tr><tr><td id="L944" class="nb">944</td><td>      #   Post.joins(:comments)</td></tr><tr><td id="L945" class="nb">945</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ...</td></tr><tr><td id="L946" class="nb">946</td><td>      #   Post.joins(:special_comments) # STI</td></tr><tr><td id="L947" class="nb">947</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'</td></tr><tr><td id="L948" class="nb">948</td><td>      #   Post.joins(:comments, :special_comments) # special_comments is the reflection name, posts is the parent table name</td></tr><tr><td id="L949" class="nb">949</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts</td></tr><tr><td id="L950" class="nb">950</td><td>      #</td></tr><tr><td id="L951" class="nb">951</td><td>      # Acts as tree example:</td></tr><tr><td id="L952" class="nb">952</td><td>      #</td></tr><tr><td id="L953" class="nb">953</td><td>      #   TreeMixin.joins(:children)</td></tr><tr><td id="L954" class="nb">954</td><td>      #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...</td></tr><tr><td id="L955" class="nb">955</td><td>      #   TreeMixin.joins(children: :parent)</td></tr><tr><td id="L956" class="nb">956</td><td>      #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...</td></tr><tr><td id="L957" class="nb">957</td><td>      #                               INNER JOIN parents_mixins ...</td></tr><tr><td id="L958" class="nb">958</td><td>      #   TreeMixin.joins(children: {parent: :children})</td></tr><tr><td id="L959" class="nb">959</td><td>      #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...</td></tr><tr><td id="L960" class="nb">960</td><td>      #                               INNER JOIN parents_mixins ...</td></tr><tr><td id="L961" class="nb">961</td><td>      #                               INNER JOIN mixins childrens_mixins_2</td></tr><tr><td id="L962" class="nb">962</td><td>      #</td></tr><tr><td id="L963" class="nb">963</td><td>      # Has and Belongs to Many join tables use the same idea, but add a &lt;tt&gt;_join&lt;/tt&gt; suffix:</td></tr><tr><td id="L964" class="nb">964</td><td>      #</td></tr><tr><td id="L965" class="nb">965</td><td>      #   Post.joins(:categories)</td></tr><tr><td id="L966" class="nb">966</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...</td></tr><tr><td id="L967" class="nb">967</td><td>      #   Post.joins(categories: :posts)</td></tr><tr><td id="L968" class="nb">968</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...</td></tr><tr><td id="L969" class="nb">969</td><td>      #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories</td></tr><tr><td id="L970" class="nb">970</td><td>      #   Post.joins(categories: {posts: :categories})</td></tr><tr><td id="L971" class="nb">971</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...</td></tr><tr><td id="L972" class="nb">972</td><td>      #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories</td></tr><tr><td id="L973" class="nb">973</td><td>      #                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2</td></tr><tr><td id="L974" class="nb">974</td><td>      #</td></tr><tr><td id="L975" class="nb">975</td><td>      # If you wish to specify your own custom joins using ActiveRecord::QueryMethods#joins method, those table</td></tr><tr><td id="L976" class="nb">976</td><td>      # names will take precedence over the eager associations:</td></tr><tr><td id="L977" class="nb">977</td><td>      #</td></tr><tr><td id="L978" class="nb">978</td><td>      #   Post.joins(:comments).joins("inner join comments ...")</td></tr><tr><td id="L979" class="nb">979</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...</td></tr><tr><td id="L980" class="nb">980</td><td>      #   Post.joins(:comments, :special_comments).joins("inner join comments ...")</td></tr><tr><td id="L981" class="nb">981</td><td>      #   # =&gt; SELECT ... FROM posts INNER JOIN comments comments_posts ON ...</td></tr><tr><td id="L982" class="nb">982</td><td>      #                              INNER JOIN comments special_comments_posts ...</td></tr><tr><td id="L983" class="nb">983</td><td>      #                              INNER JOIN comments ...</td></tr><tr><td id="L984" class="nb">984</td><td>      #</td></tr><tr><td id="L985" class="nb">985</td><td>      # Table aliases are automatically truncated according to the maximum length of table identifiers</td></tr><tr><td id="L986" class="nb">986</td><td>      # according to the specific database.</td></tr><tr><td id="L987" class="nb">987</td><td>      #</td></tr><tr><td id="L988" class="nb">988</td><td>      # == Modules</td></tr><tr><td id="L989" class="nb">989</td><td>      #</td></tr><tr><td id="L990" class="nb">990</td><td>      # By default, associations will look for objects within the current module scope. Consider:</td></tr><tr><td id="L991" class="nb">991</td><td>      #</td></tr><tr><td id="L992" class="nb">992</td><td>      #   module MyApplication</td></tr><tr><td id="L993" class="nb">993</td><td>      #     module Business</td></tr><tr><td id="L994" class="nb">994</td><td>      #       class Firm &lt; ActiveRecord::Base</td></tr><tr><td id="L995" class="nb">995</td><td>      #         has_many :clients</td></tr><tr><td id="L996" class="nb">996</td><td>      #       end</td></tr><tr><td id="L997" class="nb">997</td><td>      #</td></tr><tr><td id="L998" class="nb">998</td><td>      #       class Client &lt; ActiveRecord::Base; end</td></tr><tr><td id="L999" class="nb">999</td><td>      #     end</td></tr><tr><td id="L1000" class="nb">1000</td><td>      #   end</td></tr><tr><td id="L1001" class="nb">1001</td><td>      #</td></tr><tr><td id="L1002" class="nb">1002</td><td>      # When &lt;tt&gt;Firm#clients&lt;/tt&gt; is called, it will in turn call</td></tr><tr><td id="L1003" class="nb">1003</td><td>      # &lt;tt&gt;MyApplication::Business::Client.find_all_by_firm_id(firm.id)&lt;/tt&gt;.</td></tr><tr><td id="L1004" class="nb">1004</td><td>      # If you want to associate with a class in another module scope, this can be done by</td></tr><tr><td id="L1005" class="nb">1005</td><td>      # specifying the complete class name.</td></tr><tr><td id="L1006" class="nb">1006</td><td>      #</td></tr><tr><td id="L1007" class="nb">1007</td><td>      #   module MyApplication</td></tr><tr><td id="L1008" class="nb">1008</td><td>      #     module Business</td></tr><tr><td id="L1009" class="nb">1009</td><td>      #       class Firm &lt; ActiveRecord::Base; end</td></tr><tr><td id="L1010" class="nb">1010</td><td>      #     end</td></tr><tr><td id="L1011" class="nb">1011</td><td>      #</td></tr><tr><td id="L1012" class="nb">1012</td><td>      #     module Billing</td></tr><tr><td id="L1013" class="nb">1013</td><td>      #       class Account &lt; ActiveRecord::Base</td></tr><tr><td id="L1014" class="nb">1014</td><td>      #         belongs_to :firm, class_name: "MyApplication::Business::Firm"</td></tr><tr><td id="L1015" class="nb">1015</td><td>      #       end</td></tr><tr><td id="L1016" class="nb">1016</td><td>      #     end</td></tr><tr><td id="L1017" class="nb">1017</td><td>      #   end</td></tr><tr><td id="L1018" class="nb">1018</td><td>      #</td></tr><tr><td id="L1019" class="nb">1019</td><td>      # == Bi-directional associations</td></tr><tr><td id="L1020" class="nb">1020</td><td>      #</td></tr><tr><td id="L1021" class="nb">1021</td><td>      # When you specify an association, there is usually an association on the associated model</td></tr><tr><td id="L1022" class="nb">1022</td><td>      # that specifies the same relationship in reverse. For example, with the following models:</td></tr><tr><td id="L1023" class="nb">1023</td><td>      #</td></tr><tr><td id="L1024" class="nb">1024</td><td>      #    class Dungeon &lt; ActiveRecord::Base</td></tr><tr><td id="L1025" class="nb">1025</td><td>      #      has_many :traps</td></tr><tr><td id="L1026" class="nb">1026</td><td>      #      has_one :evil_wizard</td></tr><tr><td id="L1027" class="nb">1027</td><td>      #    end</td></tr><tr><td id="L1028" class="nb">1028</td><td>      #</td></tr><tr><td id="L1029" class="nb">1029</td><td>      #    class Trap &lt; ActiveRecord::Base</td></tr><tr><td id="L1030" class="nb">1030</td><td>      #      belongs_to :dungeon</td></tr><tr><td id="L1031" class="nb">1031</td><td>      #    end</td></tr><tr><td id="L1032" class="nb">1032</td><td>      #</td></tr><tr><td id="L1033" class="nb">1033</td><td>      #    class EvilWizard &lt; ActiveRecord::Base</td></tr><tr><td id="L1034" class="nb">1034</td><td>      #      belongs_to :dungeon</td></tr><tr><td id="L1035" class="nb">1035</td><td>      #    end</td></tr><tr><td id="L1036" class="nb">1036</td><td>      #</td></tr><tr><td id="L1037" class="nb">1037</td><td>      # The +traps+ association on +Dungeon+ and the +dungeon+ association on +Trap+ are</td></tr><tr><td id="L1038" class="nb">1038</td><td>      # the inverse of each other, and the inverse of the +dungeon+ association on +EvilWizard+</td></tr><tr><td id="L1039" class="nb">1039</td><td>      # is the +evil_wizard+ association on +Dungeon+ (and vice-versa). By default,</td></tr><tr><td id="L1040" class="nb">1040</td><td>      # Active Record can guess the inverse of the association based on the name</td></tr><tr><td id="L1041" class="nb">1041</td><td>      # of the class. The result is the following:</td></tr><tr><td id="L1042" class="nb">1042</td><td>      #</td></tr><tr><td id="L1043" class="nb">1043</td><td>      #    d = Dungeon.first</td></tr><tr><td id="L1044" class="nb">1044</td><td>      #    t = d.traps.first</td></tr><tr><td id="L1045" class="nb">1045</td><td>      #    d.object_id == t.dungeon.object_id # =&gt; true</td></tr><tr><td id="L1046" class="nb">1046</td><td>      #</td></tr><tr><td id="L1047" class="nb">1047</td><td>      # The +Dungeon+ instances +d+ and &lt;tt&gt;t.dungeon&lt;/tt&gt; in the above example refer to</td></tr><tr><td id="L1048" class="nb">1048</td><td>      # the same in-memory instance since the association matches the name of the class.</td></tr><tr><td id="L1049" class="nb">1049</td><td>      # The result would be the same if we added +:inverse_of+ to our model definitions:</td></tr><tr><td id="L1050" class="nb">1050</td><td>      #</td></tr><tr><td id="L1051" class="nb">1051</td><td>      #    class Dungeon &lt; ActiveRecord::Base</td></tr><tr><td id="L1052" class="nb">1052</td><td>      #      has_many :traps, inverse_of: :dungeon</td></tr><tr><td id="L1053" class="nb">1053</td><td>      #      has_one :evil_wizard, inverse_of: :dungeon</td></tr><tr><td id="L1054" class="nb">1054</td><td>      #    end</td></tr><tr><td id="L1055" class="nb">1055</td><td>      #</td></tr><tr><td id="L1056" class="nb">1056</td><td>      #    class Trap &lt; ActiveRecord::Base</td></tr><tr><td id="L1057" class="nb">1057</td><td>      #      belongs_to :dungeon, inverse_of: :traps</td></tr><tr><td id="L1058" class="nb">1058</td><td>      #    end</td></tr><tr><td id="L1059" class="nb">1059</td><td>      #</td></tr><tr><td id="L1060" class="nb">1060</td><td>      #    class EvilWizard &lt; ActiveRecord::Base</td></tr><tr><td id="L1061" class="nb">1061</td><td>      #      belongs_to :dungeon, inverse_of: :evil_wizard</td></tr><tr><td id="L1062" class="nb">1062</td><td>      #    end</td></tr><tr><td id="L1063" class="nb">1063</td><td>      #</td></tr><tr><td id="L1064" class="nb">1064</td><td>      # There are limitations to &lt;tt&gt;:inverse_of&lt;/tt&gt; support:</td></tr><tr><td id="L1065" class="nb">1065</td><td>      #</td></tr><tr><td id="L1066" class="nb">1066</td><td>      # * does not work with &lt;tt&gt;:through&lt;/tt&gt; associations.</td></tr><tr><td id="L1067" class="nb">1067</td><td>      # * does not work with &lt;tt&gt;:polymorphic&lt;/tt&gt; associations.</td></tr><tr><td id="L1068" class="nb">1068</td><td>      # * inverse associations for #belongs_to associations #has_many are ignored.</td></tr><tr><td id="L1069" class="nb">1069</td><td>      #</td></tr><tr><td id="L1070" class="nb">1070</td><td>      # For more information, see the documentation for the +:inverse_of+ option.</td></tr><tr><td id="L1071" class="nb">1071</td><td>      #</td></tr><tr><td id="L1072" class="nb">1072</td><td>      # == Deleting from associations</td></tr><tr><td id="L1073" class="nb">1073</td><td>      #</td></tr><tr><td id="L1074" class="nb">1074</td><td>      # === Dependent associations</td></tr><tr><td id="L1075" class="nb">1075</td><td>      #</td></tr><tr><td id="L1076" class="nb">1076</td><td>      # #has_many, #has_one, and #belongs_to associations support the &lt;tt&gt;:dependent&lt;/tt&gt; option.</td></tr><tr><td id="L1077" class="nb">1077</td><td>      # This allows you to specify that associated records should be deleted when the owner is</td></tr><tr><td id="L1078" class="nb">1078</td><td>      # deleted.</td></tr><tr><td id="L1079" class="nb">1079</td><td>      #</td></tr><tr><td id="L1080" class="nb">1080</td><td>      # For example:</td></tr><tr><td id="L1081" class="nb">1081</td><td>      #</td></tr><tr><td id="L1082" class="nb">1082</td><td>      #     class Author</td></tr><tr><td id="L1083" class="nb">1083</td><td>      #       has_many :posts, dependent: :destroy</td></tr><tr><td id="L1084" class="nb">1084</td><td>      #     end</td></tr><tr><td id="L1085" class="nb">1085</td><td>      #     Author.find(1).destroy # =&gt; Will destroy all of the author's posts, too</td></tr><tr><td id="L1086" class="nb">1086</td><td>      #</td></tr><tr><td id="L1087" class="nb">1087</td><td>      # The &lt;tt&gt;:dependent&lt;/tt&gt; option can have different values which specify how the deletion</td></tr><tr><td id="L1088" class="nb">1088</td><td>      # is done. For more information, see the documentation for this option on the different</td></tr><tr><td id="L1089" class="nb">1089</td><td>      # specific association types. When no option is given, the behavior is to do nothing</td></tr><tr><td id="L1090" class="nb">1090</td><td>      # with the associated records when destroying a record.</td></tr><tr><td id="L1091" class="nb">1091</td><td>      #</td></tr><tr><td id="L1092" class="nb">1092</td><td>      # Note that &lt;tt&gt;:dependent&lt;/tt&gt; is implemented using Rails' callback</td></tr><tr><td id="L1093" class="nb">1093</td><td>      # system, which works by processing callbacks in order. Therefore, other</td></tr><tr><td id="L1094" class="nb">1094</td><td>      # callbacks declared either before or after the &lt;tt&gt;:dependent&lt;/tt&gt; option</td></tr><tr><td id="L1095" class="nb">1095</td><td>      # can affect what it does.</td></tr><tr><td id="L1096" class="nb">1096</td><td>      #</td></tr><tr><td id="L1097" class="nb">1097</td><td>      # Note that &lt;tt&gt;:dependent&lt;/tt&gt; option is ignored for #has_one &lt;tt&gt;:through&lt;/tt&gt; associations.</td></tr><tr><td id="L1098" class="nb">1098</td><td>      #</td></tr><tr><td id="L1099" class="nb">1099</td><td>      # === Delete or destroy?</td></tr><tr><td id="L1100" class="nb">1100</td><td>      #</td></tr><tr><td id="L1101" class="nb">1101</td><td>      # #has_many and #has_and_belongs_to_many associations have the methods &lt;tt&gt;destroy&lt;/tt&gt;,</td></tr><tr><td id="L1102" class="nb">1102</td><td>      # &lt;tt&gt;delete&lt;/tt&gt;, &lt;tt&gt;destroy_all&lt;/tt&gt; and &lt;tt&gt;delete_all&lt;/tt&gt;.</td></tr><tr><td id="L1103" class="nb">1103</td><td>      #</td></tr><tr><td id="L1104" class="nb">1104</td><td>      # For #has_and_belongs_to_many, &lt;tt&gt;delete&lt;/tt&gt; and &lt;tt&gt;destroy&lt;/tt&gt; are the same: they</td></tr><tr><td id="L1105" class="nb">1105</td><td>      # cause the records in the join table to be removed.</td></tr><tr><td id="L1106" class="nb">1106</td><td>      #</td></tr><tr><td id="L1107" class="nb">1107</td><td>      # For #has_many, &lt;tt&gt;destroy&lt;/tt&gt; and &lt;tt&gt;destroy_all&lt;/tt&gt; will always call the &lt;tt&gt;destroy&lt;/tt&gt; method of the</td></tr><tr><td id="L1108" class="nb">1108</td><td>      # record(s) being removed so that callbacks are run. However &lt;tt&gt;delete&lt;/tt&gt; and &lt;tt&gt;delete_all&lt;/tt&gt; will either</td></tr><tr><td id="L1109" class="nb">1109</td><td>      # do the deletion according to the strategy specified by the &lt;tt&gt;:dependent&lt;/tt&gt; option, or</td></tr><tr><td id="L1110" class="nb">1110</td><td>      # if no &lt;tt&gt;:dependent&lt;/tt&gt; option is given, then it will follow the default strategy.</td></tr><tr><td id="L1111" class="nb">1111</td><td>      # The default strategy is to do nothing (leave the foreign keys with the parent ids set), except for</td></tr><tr><td id="L1112" class="nb">1112</td><td>      # #has_many &lt;tt&gt;:through&lt;/tt&gt;, where the default strategy is &lt;tt&gt;delete_all&lt;/tt&gt; (delete</td></tr><tr><td id="L1113" class="nb">1113</td><td>      # the join records, without running their callbacks).</td></tr><tr><td id="L1114" class="nb">1114</td><td>      #</td></tr><tr><td id="L1115" class="nb">1115</td><td>      # There is also a &lt;tt&gt;clear&lt;/tt&gt; method which is the same as &lt;tt&gt;delete_all&lt;/tt&gt;, except that</td></tr><tr><td id="L1116" class="nb">1116</td><td>      # it returns the association rather than the records which have been deleted.</td></tr><tr><td id="L1117" class="nb">1117</td><td>      #</td></tr><tr><td id="L1118" class="nb">1118</td><td>      # === What gets deleted?</td></tr><tr><td id="L1119" class="nb">1119</td><td>      #</td></tr><tr><td id="L1120" class="nb">1120</td><td>      # There is a potential pitfall here: #has_and_belongs_to_many and #has_many &lt;tt&gt;:through&lt;/tt&gt;</td></tr><tr><td id="L1121" class="nb">1121</td><td>      # associations have records in join tables, as well as the associated records. So when we</td></tr><tr><td id="L1122" class="nb">1122</td><td>      # call one of these deletion methods, what exactly should be deleted?</td></tr><tr><td id="L1123" class="nb">1123</td><td>      #</td></tr><tr><td id="L1124" class="nb">1124</td><td>      # The answer is that it is assumed that deletion on an association is about removing the</td></tr><tr><td id="L1125" class="nb">1125</td><td>      # &lt;i&gt;link&lt;/i&gt; between the owner and the associated object(s), rather than necessarily the</td></tr><tr><td id="L1126" class="nb">1126</td><td>      # associated objects themselves. So with #has_and_belongs_to_many and #has_many</td></tr><tr><td id="L1127" class="nb">1127</td><td>      # &lt;tt&gt;:through&lt;/tt&gt;, the join records will be deleted, but the associated records won't.</td></tr><tr><td id="L1128" class="nb">1128</td><td>      #</td></tr><tr><td id="L1129" class="nb">1129</td><td>      # This makes sense if you think about it: if you were to call &lt;tt&gt;post.tags.delete(Tag.find_by(name: 'food'))&lt;/tt&gt;</td></tr><tr><td id="L1130" class="nb">1130</td><td>      # you would want the 'food' tag to be unlinked from the post, rather than for the tag itself</td></tr><tr><td id="L1131" class="nb">1131</td><td>      # to be removed from the database.</td></tr><tr><td id="L1132" class="nb">1132</td><td>      #</td></tr><tr><td id="L1133" class="nb">1133</td><td>      # However, there are examples where this strategy doesn't make sense. For example, suppose</td></tr><tr><td id="L1134" class="nb">1134</td><td>      # a person has many projects, and each project has many tasks. If we deleted one of a person's</td></tr><tr><td id="L1135" class="nb">1135</td><td>      # tasks, we would probably not want the project to be deleted. In this scenario, the delete method</td></tr><tr><td id="L1136" class="nb">1136</td><td>      # won't actually work: it can only be used if the association on the join model is a</td></tr><tr><td id="L1137" class="nb">1137</td><td>      # #belongs_to. In other situations you are expected to perform operations directly on</td></tr><tr><td id="L1138" class="nb">1138</td><td>      # either the associated records or the &lt;tt&gt;:through&lt;/tt&gt; association.</td></tr><tr><td id="L1139" class="nb">1139</td><td>      #</td></tr><tr><td id="L1140" class="nb">1140</td><td>      # With a regular #has_many there is no distinction between the "associated records"</td></tr><tr><td id="L1141" class="nb">1141</td><td>      # and the "link", so there is only one choice for what gets deleted.</td></tr><tr><td id="L1142" class="nb">1142</td><td>      #</td></tr><tr><td id="L1143" class="nb">1143</td><td>      # With #has_and_belongs_to_many and #has_many &lt;tt&gt;:through&lt;/tt&gt;, if you want to delete the</td></tr><tr><td id="L1144" class="nb">1144</td><td>      # associated records themselves, you can always do something along the lines of</td></tr><tr><td id="L1145" class="nb">1145</td><td>      # &lt;tt&gt;person.tasks.each(&amp;:destroy)&lt;/tt&gt;.</td></tr><tr><td id="L1146" class="nb">1146</td><td>      #</td></tr><tr><td id="L1147" class="nb">1147</td><td>      # == Type safety with ActiveRecord::AssociationTypeMismatch</td></tr><tr><td id="L1148" class="nb">1148</td><td>      #</td></tr><tr><td id="L1149" class="nb">1149</td><td>      # If you attempt to assign an object to an association that doesn't match the inferred</td></tr><tr><td id="L1150" class="nb">1150</td><td>      # or specified &lt;tt&gt;:class_name&lt;/tt&gt;, you'll get an ActiveRecord::AssociationTypeMismatch.</td></tr><tr><td id="L1151" class="nb">1151</td><td>      #</td></tr><tr><td id="L1152" class="nb">1152</td><td>      # == Options</td></tr><tr><td id="L1153" class="nb">1153</td><td>      #</td></tr><tr><td id="L1154" class="nb">1154</td><td>      # All of the association macros can be specialized through options. This makes cases</td></tr><tr><td id="L1155" class="nb">1155</td><td>      # more complex than the simple and guessable ones possible.</td></tr><tr><td id="L1156" class="nb">1156</td><td>      <span class="node-module kind-keyword run" title="11x">module</span> <span class="node-const kind-name run" title="11x">ClassMethods</span></td></tr><tr><td id="L1157" class="nb">1157</td><td>        # Specifies a one-to-many association. The following methods for retrieval and query of</td></tr><tr><td id="L1158" class="nb">1158</td><td>        # collections of associated objects will be added:</td></tr><tr><td id="L1159" class="nb">1159</td><td>        #</td></tr><tr><td id="L1160" class="nb">1160</td><td>        # +collection+ is a placeholder for the symbol passed as the +name+ argument, so</td></tr><tr><td id="L1161" class="nb">1161</td><td>        # &lt;tt&gt;has_many :clients&lt;/tt&gt; would add among others &lt;tt&gt;clients.empty?&lt;/tt&gt;.</td></tr><tr><td id="L1162" class="nb">1162</td><td>        #</td></tr><tr><td id="L1163" class="nb">1163</td><td>        # [collection]</td></tr><tr><td id="L1164" class="nb">1164</td><td>        #   Returns a Relation of all the associated objects.</td></tr><tr><td id="L1165" class="nb">1165</td><td>        #   An empty Relation is returned if none are found.</td></tr><tr><td id="L1166" class="nb">1166</td><td>        # [collection&lt;&lt;(object, ...)]</td></tr><tr><td id="L1167" class="nb">1167</td><td>        #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.</td></tr><tr><td id="L1168" class="nb">1168</td><td>        #   Note that this operation instantly fires update SQL without waiting for the save or update call on the</td></tr><tr><td id="L1169" class="nb">1169</td><td>        #   parent object, unless the parent object is a new record.</td></tr><tr><td id="L1170" class="nb">1170</td><td>        #   This will also run validations and callbacks of associated object(s).</td></tr><tr><td id="L1171" class="nb">1171</td><td>        # [collection.delete(object, ...)]</td></tr><tr><td id="L1172" class="nb">1172</td><td>        #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.</td></tr><tr><td id="L1173" class="nb">1173</td><td>        #   Objects will be in addition destroyed if they're associated with &lt;tt&gt;dependent: :destroy&lt;/tt&gt;,</td></tr><tr><td id="L1174" class="nb">1174</td><td>        #   and deleted if they're associated with &lt;tt&gt;dependent: :delete_all&lt;/tt&gt;.</td></tr><tr><td id="L1175" class="nb">1175</td><td>        #</td></tr><tr><td id="L1176" class="nb">1176</td><td>        #   If the &lt;tt&gt;:through&lt;/tt&gt; option is used, then the join records are deleted (rather than</td></tr><tr><td id="L1177" class="nb">1177</td><td>        #   nullified) by default, but you can specify &lt;tt&gt;dependent: :destroy&lt;/tt&gt; or</td></tr><tr><td id="L1178" class="nb">1178</td><td>        #   &lt;tt&gt;dependent: :nullify&lt;/tt&gt; to override this.</td></tr><tr><td id="L1179" class="nb">1179</td><td>        # [collection.destroy(object, ...)]</td></tr><tr><td id="L1180" class="nb">1180</td><td>        #   Removes one or more objects from the collection by running &lt;tt&gt;destroy&lt;/tt&gt; on</td></tr><tr><td id="L1181" class="nb">1181</td><td>        #   each record, regardless of any dependent option, ensuring callbacks are run.</td></tr><tr><td id="L1182" class="nb">1182</td><td>        #</td></tr><tr><td id="L1183" class="nb">1183</td><td>        #   If the &lt;tt&gt;:through&lt;/tt&gt; option is used, then the join records are destroyed</td></tr><tr><td id="L1184" class="nb">1184</td><td>        #   instead, not the objects themselves.</td></tr><tr><td id="L1185" class="nb">1185</td><td>        # [collection=objects]</td></tr><tr><td id="L1186" class="nb">1186</td><td>        #   Replaces the collections content by deleting and adding objects as appropriate. If the &lt;tt&gt;:through&lt;/tt&gt;</td></tr><tr><td id="L1187" class="nb">1187</td><td>        #   option is true callbacks in the join models are triggered except destroy callbacks, since deletion is</td></tr><tr><td id="L1188" class="nb">1188</td><td>        #   direct by default. You can specify &lt;tt&gt;dependent: :destroy&lt;/tt&gt; or</td></tr><tr><td id="L1189" class="nb">1189</td><td>        #   &lt;tt&gt;dependent: :nullify&lt;/tt&gt; to override this.</td></tr><tr><td id="L1190" class="nb">1190</td><td>        # [collection_singular_ids]</td></tr><tr><td id="L1191" class="nb">1191</td><td>        #   Returns an array of the associated objects' ids</td></tr><tr><td id="L1192" class="nb">1192</td><td>        # [collection_singular_ids=ids]</td></tr><tr><td id="L1193" class="nb">1193</td><td>        #   Replace the collection with the objects identified by the primary keys in +ids+. This</td></tr><tr><td id="L1194" class="nb">1194</td><td>        #   method loads the models and calls &lt;tt&gt;collection=&lt;/tt&gt;. See above.</td></tr><tr><td id="L1195" class="nb">1195</td><td>        # [collection.clear]</td></tr><tr><td id="L1196" class="nb">1196</td><td>        #   Removes every object from the collection. This destroys the associated objects if they</td></tr><tr><td id="L1197" class="nb">1197</td><td>        #   are associated with &lt;tt&gt;dependent: :destroy&lt;/tt&gt;, deletes them directly from the</td></tr><tr><td id="L1198" class="nb">1198</td><td>        #   database if &lt;tt&gt;dependent: :delete_all&lt;/tt&gt;, otherwise sets their foreign keys to +NULL+.</td></tr><tr><td id="L1199" class="nb">1199</td><td>        #   If the &lt;tt&gt;:through&lt;/tt&gt; option is true no destroy callbacks are invoked on the join models.</td></tr><tr><td id="L1200" class="nb">1200</td><td>        #   Join models are directly deleted.</td></tr><tr><td id="L1201" class="nb">1201</td><td>        # [collection.empty?]</td></tr><tr><td id="L1202" class="nb">1202</td><td>        #   Returns +true+ if there are no associated objects.</td></tr><tr><td id="L1203" class="nb">1203</td><td>        # [collection.size]</td></tr><tr><td id="L1204" class="nb">1204</td><td>        #   Returns the number of associated objects.</td></tr><tr><td id="L1205" class="nb">1205</td><td>        # [collection.find(...)]</td></tr><tr><td id="L1206" class="nb">1206</td><td>        #   Finds an associated object according to the same rules as ActiveRecord::FinderMethods#find.</td></tr><tr><td id="L1207" class="nb">1207</td><td>        # [collection.exists?(...)]</td></tr><tr><td id="L1208" class="nb">1208</td><td>        #   Checks whether an associated object with the given conditions exists.</td></tr><tr><td id="L1209" class="nb">1209</td><td>        #   Uses the same rules as ActiveRecord::FinderMethods#exists?.</td></tr><tr><td id="L1210" class="nb">1210</td><td>        # [collection.build(attributes = {}, ...)]</td></tr><tr><td id="L1211" class="nb">1211</td><td>        #   Returns one or more new objects of the collection type that have been instantiated</td></tr><tr><td id="L1212" class="nb">1212</td><td>        #   with +attributes+ and linked to this object through a foreign key, but have not yet</td></tr><tr><td id="L1213" class="nb">1213</td><td>        #   been saved.</td></tr><tr><td id="L1214" class="nb">1214</td><td>        # [collection.create(attributes = {})]</td></tr><tr><td id="L1215" class="nb">1215</td><td>        #   Returns a new object of the collection type that has been instantiated</td></tr><tr><td id="L1216" class="nb">1216</td><td>        #   with +attributes+, linked to this object through a foreign key, and that has already</td></tr><tr><td id="L1217" class="nb">1217</td><td>        #   been saved (if it passed the validation). *Note*: This only works if the base model</td></tr><tr><td id="L1218" class="nb">1218</td><td>        #   already exists in the DB, not if it is a new (unsaved) record!</td></tr><tr><td id="L1219" class="nb">1219</td><td>        # [collection.create!(attributes = {})]</td></tr><tr><td id="L1220" class="nb">1220</td><td>        #   Does the same as &lt;tt&gt;collection.create&lt;/tt&gt;, but raises ActiveRecord::RecordInvalid</td></tr><tr><td id="L1221" class="nb">1221</td><td>        #   if the record is invalid.</td></tr><tr><td id="L1222" class="nb">1222</td><td>        # [collection.reload]</td></tr><tr><td id="L1223" class="nb">1223</td><td>        #   Returns a Relation of all of the associated objects, forcing a database read.</td></tr><tr><td id="L1224" class="nb">1224</td><td>        #   An empty Relation is returned if none are found.</td></tr><tr><td id="L1225" class="nb">1225</td><td>        #</td></tr><tr><td id="L1226" class="nb">1226</td><td>        # === Example</td></tr><tr><td id="L1227" class="nb">1227</td><td>        #</td></tr><tr><td id="L1228" class="nb">1228</td><td>        # A &lt;tt&gt;Firm&lt;/tt&gt; class declares &lt;tt&gt;has_many :clients&lt;/tt&gt;, which will add:</td></tr><tr><td id="L1229" class="nb">1229</td><td>        # * &lt;tt&gt;Firm#clients&lt;/tt&gt; (similar to &lt;tt&gt;Client.where(firm_id: id)&lt;/tt&gt;)</td></tr><tr><td id="L1230" class="nb">1230</td><td>        # * &lt;tt&gt;Firm#clients&lt;&lt;&lt;/tt&gt;</td></tr><tr><td id="L1231" class="nb">1231</td><td>        # * &lt;tt&gt;Firm#clients.delete&lt;/tt&gt;</td></tr><tr><td id="L1232" class="nb">1232</td><td>        # * &lt;tt&gt;Firm#clients.destroy&lt;/tt&gt;</td></tr><tr><td id="L1233" class="nb">1233</td><td>        # * &lt;tt&gt;Firm#clients=&lt;/tt&gt;</td></tr><tr><td id="L1234" class="nb">1234</td><td>        # * &lt;tt&gt;Firm#client_ids&lt;/tt&gt;</td></tr><tr><td id="L1235" class="nb">1235</td><td>        # * &lt;tt&gt;Firm#client_ids=&lt;/tt&gt;</td></tr><tr><td id="L1236" class="nb">1236</td><td>        # * &lt;tt&gt;Firm#clients.clear&lt;/tt&gt;</td></tr><tr><td id="L1237" class="nb">1237</td><td>        # * &lt;tt&gt;Firm#clients.empty?&lt;/tt&gt; (similar to &lt;tt&gt;firm.clients.size == 0&lt;/tt&gt;)</td></tr><tr><td id="L1238" class="nb">1238</td><td>        # * &lt;tt&gt;Firm#clients.size&lt;/tt&gt; (similar to &lt;tt&gt;Client.count "firm_id = #{id}"&lt;/tt&gt;)</td></tr><tr><td id="L1239" class="nb">1239</td><td>        # * &lt;tt&gt;Firm#clients.find&lt;/tt&gt; (similar to &lt;tt&gt;Client.where(firm_id: id).find(id)&lt;/tt&gt;)</td></tr><tr><td id="L1240" class="nb">1240</td><td>        # * &lt;tt&gt;Firm#clients.exists?(name: 'ACME')&lt;/tt&gt; (similar to &lt;tt&gt;Client.exists?(name: 'ACME', firm_id: firm.id)&lt;/tt&gt;)</td></tr><tr><td id="L1241" class="nb">1241</td><td>        # * &lt;tt&gt;Firm#clients.build&lt;/tt&gt; (similar to &lt;tt&gt;Client.new("firm_id" =&gt; id)&lt;/tt&gt;)</td></tr><tr><td id="L1242" class="nb">1242</td><td>        # * &lt;tt&gt;Firm#clients.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Client.new("firm_id" =&gt; id); c.save; c&lt;/tt&gt;)</td></tr><tr><td id="L1243" class="nb">1243</td><td>        # * &lt;tt&gt;Firm#clients.create!&lt;/tt&gt; (similar to &lt;tt&gt;c = Client.new("firm_id" =&gt; id); c.save!&lt;/tt&gt;)</td></tr><tr><td id="L1244" class="nb">1244</td><td>        # * &lt;tt&gt;Firm#clients.reload&lt;/tt&gt;</td></tr><tr><td id="L1245" class="nb">1245</td><td>        # The declaration can also include an +options+ hash to specialize the behavior of the association.</td></tr><tr><td id="L1246" class="nb">1246</td><td>        #</td></tr><tr><td id="L1247" class="nb">1247</td><td>        # === Scopes</td></tr><tr><td id="L1248" class="nb">1248</td><td>        #</td></tr><tr><td id="L1249" class="nb">1249</td><td>        # You can pass a second argument +scope+ as a callable (i.e. proc or</td></tr><tr><td id="L1250" class="nb">1250</td><td>        # lambda) to retrieve a specific set of records or customize the generated</td></tr><tr><td id="L1251" class="nb">1251</td><td>        # query when you access the associated collection.</td></tr><tr><td id="L1252" class="nb">1252</td><td>        #</td></tr><tr><td id="L1253" class="nb">1253</td><td>        # Scope examples:</td></tr><tr><td id="L1254" class="nb">1254</td><td>        #   has_many :comments, -&gt; { where(author_id: 1) }</td></tr><tr><td id="L1255" class="nb">1255</td><td>        #   has_many :employees, -&gt; { joins(:address) }</td></tr><tr><td id="L1256" class="nb">1256</td><td>        #   has_many :posts, -&gt;(blog) { where("max_post_length &gt; ?", blog.max_post_length) }</td></tr><tr><td id="L1257" class="nb">1257</td><td>        #</td></tr><tr><td id="L1258" class="nb">1258</td><td>        # === Extensions</td></tr><tr><td id="L1259" class="nb">1259</td><td>        #</td></tr><tr><td id="L1260" class="nb">1260</td><td>        # The +extension+ argument allows you to pass a block into a has_many</td></tr><tr><td id="L1261" class="nb">1261</td><td>        # association. This is useful for adding new finders, creators and other</td></tr><tr><td id="L1262" class="nb">1262</td><td>        # factory-type methods to be used as part of the association.</td></tr><tr><td id="L1263" class="nb">1263</td><td>        #</td></tr><tr><td id="L1264" class="nb">1264</td><td>        # Extension examples:</td></tr><tr><td id="L1265" class="nb">1265</td><td>        #   has_many :employees do</td></tr><tr><td id="L1266" class="nb">1266</td><td>        #     def find_or_create_by_name(name)</td></tr><tr><td id="L1267" class="nb">1267</td><td>        #       first_name, last_name = name.split(" ", 2)</td></tr><tr><td id="L1268" class="nb">1268</td><td>        #       find_or_create_by(first_name: first_name, last_name: last_name)</td></tr><tr><td id="L1269" class="nb">1269</td><td>        #     end</td></tr><tr><td id="L1270" class="nb">1270</td><td>        #   end</td></tr><tr><td id="L1271" class="nb">1271</td><td>        #</td></tr><tr><td id="L1272" class="nb">1272</td><td>        # === Options</td></tr><tr><td id="L1273" class="nb">1273</td><td>        # [:class_name]</td></tr><tr><td id="L1274" class="nb">1274</td><td>        #   Specify the class name of the association. Use it only if that name can't be inferred</td></tr><tr><td id="L1275" class="nb">1275</td><td>        #   from the association name. So &lt;tt&gt;has_many :products&lt;/tt&gt; will by default be linked</td></tr><tr><td id="L1276" class="nb">1276</td><td>        #   to the +Product+ class, but if the real class name is +SpecialProduct+, you'll have to</td></tr><tr><td id="L1277" class="nb">1277</td><td>        #   specify it with this option.</td></tr><tr><td id="L1278" class="nb">1278</td><td>        # [:foreign_key]</td></tr><tr><td id="L1279" class="nb">1279</td><td>        #   Specify the foreign key used for the association. By default this is guessed to be the name</td></tr><tr><td id="L1280" class="nb">1280</td><td>        #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_many</td></tr><tr><td id="L1281" class="nb">1281</td><td>        #   association will use "person_id" as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.</td></tr><tr><td id="L1282" class="nb">1282</td><td>        # [:foreign_type]</td></tr><tr><td id="L1283" class="nb">1283</td><td>        #   Specify the column used to store the associated object's type, if this is a polymorphic</td></tr><tr><td id="L1284" class="nb">1284</td><td>        #   association. By default this is guessed to be the name of the polymorphic association</td></tr><tr><td id="L1285" class="nb">1285</td><td>        #   specified on "as" option with a "_type" suffix. So a class that defines a</td></tr><tr><td id="L1286" class="nb">1286</td><td>        #   &lt;tt&gt;has_many :tags, as: :taggable&lt;/tt&gt; association will use "taggable_type" as the</td></tr><tr><td id="L1287" class="nb">1287</td><td>        #   default &lt;tt&gt;:foreign_type&lt;/tt&gt;.</td></tr><tr><td id="L1288" class="nb">1288</td><td>        # [:primary_key]</td></tr><tr><td id="L1289" class="nb">1289</td><td>        #   Specify the name of the column to use as the primary key for the association. By default this is +id+.</td></tr><tr><td id="L1290" class="nb">1290</td><td>        # [:dependent]</td></tr><tr><td id="L1291" class="nb">1291</td><td>        #   Controls what happens to the associated objects when</td></tr><tr><td id="L1292" class="nb">1292</td><td>        #   their owner is destroyed. Note that these are implemented as</td></tr><tr><td id="L1293" class="nb">1293</td><td>        #   callbacks, and Rails executes callbacks in order. Therefore, other</td></tr><tr><td id="L1294" class="nb">1294</td><td>        #   similar callbacks may affect the &lt;tt&gt;:dependent&lt;/tt&gt; behavior, and the</td></tr><tr><td id="L1295" class="nb">1295</td><td>        #   &lt;tt&gt;:dependent&lt;/tt&gt; behavior may affect other callbacks.</td></tr><tr><td id="L1296" class="nb">1296</td><td>        #</td></tr><tr><td id="L1297" class="nb">1297</td><td>        #   * &lt;tt&gt;:destroy&lt;/tt&gt; causes all the associated objects to also be destroyed.</td></tr><tr><td id="L1298" class="nb">1298</td><td>        #   * &lt;tt&gt;:delete_all&lt;/tt&gt; causes all the associated objects to be deleted directly from the database (so callbacks will not be executed).</td></tr><tr><td id="L1299" class="nb">1299</td><td>        #   * &lt;tt&gt;:nullify&lt;/tt&gt; causes the foreign keys to be set to +NULL+. Callbacks are not executed.</td></tr><tr><td id="L1300" class="nb">1300</td><td>        #   * &lt;tt&gt;:restrict_with_exception&lt;/tt&gt; causes an exception to be raised if there are any associated records.</td></tr><tr><td id="L1301" class="nb">1301</td><td>        #   * &lt;tt&gt;:restrict_with_error&lt;/tt&gt; causes an error to be added to the owner if there are any associated objects.</td></tr><tr><td id="L1302" class="nb">1302</td><td>        #</td></tr><tr><td id="L1303" class="nb">1303</td><td>        #   If using with the &lt;tt&gt;:through&lt;/tt&gt; option, the association on the join model must be</td></tr><tr><td id="L1304" class="nb">1304</td><td>        #   a #belongs_to, and the records which get deleted are the join records, rather than</td></tr><tr><td id="L1305" class="nb">1305</td><td>        #   the associated records.</td></tr><tr><td id="L1306" class="nb">1306</td><td>        #</td></tr><tr><td id="L1307" class="nb">1307</td><td>        #   If using &lt;tt&gt;dependent: :destroy&lt;/tt&gt; on a scoped association, only the scoped objects are destroyed.</td></tr><tr><td id="L1308" class="nb">1308</td><td>        #   For example, if a Post model defines</td></tr><tr><td id="L1309" class="nb">1309</td><td>        #   &lt;tt&gt;has_many :comments, -&gt; { where published: true }, dependent: :destroy&lt;/tt&gt; and &lt;tt&gt;destroy&lt;/tt&gt; is</td></tr><tr><td id="L1310" class="nb">1310</td><td>        #   called on a post, only published comments are destroyed. This means that any unpublished comments in the</td></tr><tr><td id="L1311" class="nb">1311</td><td>        #   database would still contain a foreign key pointing to the now deleted post.</td></tr><tr><td id="L1312" class="nb">1312</td><td>        # [:counter_cache]</td></tr><tr><td id="L1313" class="nb">1313</td><td>        #   This option can be used to configure a custom named &lt;tt&gt;:counter_cache.&lt;/tt&gt; You only need this option,</td></tr><tr><td id="L1314" class="nb">1314</td><td>        #   when you customized the name of your &lt;tt&gt;:counter_cache&lt;/tt&gt; on the #belongs_to association.</td></tr><tr><td id="L1315" class="nb">1315</td><td>        # [:as]</td></tr><tr><td id="L1316" class="nb">1316</td><td>        #   Specifies a polymorphic interface (See #belongs_to).</td></tr><tr><td id="L1317" class="nb">1317</td><td>        # [:through]</td></tr><tr><td id="L1318" class="nb">1318</td><td>        #   Specifies an association through which to perform the query. This can be any other type</td></tr><tr><td id="L1319" class="nb">1319</td><td>        #   of association, including other &lt;tt&gt;:through&lt;/tt&gt; associations. Options for &lt;tt&gt;:class_name&lt;/tt&gt;,</td></tr><tr><td id="L1320" class="nb">1320</td><td>        #   &lt;tt&gt;:primary_key&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt; are ignored, as the association uses the</td></tr><tr><td id="L1321" class="nb">1321</td><td>        #   source reflection.</td></tr><tr><td id="L1322" class="nb">1322</td><td>        #</td></tr><tr><td id="L1323" class="nb">1323</td><td>        #   If the association on the join model is a #belongs_to, the collection can be modified</td></tr><tr><td id="L1324" class="nb">1324</td><td>        #   and the records on the &lt;tt&gt;:through&lt;/tt&gt; model will be automatically created and removed</td></tr><tr><td id="L1325" class="nb">1325</td><td>        #   as appropriate. Otherwise, the collection is read-only, so you should manipulate the</td></tr><tr><td id="L1326" class="nb">1326</td><td>        #   &lt;tt&gt;:through&lt;/tt&gt; association directly.</td></tr><tr><td id="L1327" class="nb">1327</td><td>        #</td></tr><tr><td id="L1328" class="nb">1328</td><td>        #   If you are going to modify the association (rather than just read from it), then it is</td></tr><tr><td id="L1329" class="nb">1329</td><td>        #   a good idea to set the &lt;tt&gt;:inverse_of&lt;/tt&gt; option on the source association on the</td></tr><tr><td id="L1330" class="nb">1330</td><td>        #   join model. This allows associated records to be built which will automatically create</td></tr><tr><td id="L1331" class="nb">1331</td><td>        #   the appropriate join model records when they are saved. (See the 'Association Join Models'</td></tr><tr><td id="L1332" class="nb">1332</td><td>        #   section above.)</td></tr><tr><td id="L1333" class="nb">1333</td><td>        # [:source]</td></tr><tr><td id="L1334" class="nb">1334</td><td>        #   Specifies the source association name used by #has_many &lt;tt&gt;:through&lt;/tt&gt; queries.</td></tr><tr><td id="L1335" class="nb">1335</td><td>        #   Only use it if the name cannot be inferred from the association.</td></tr><tr><td id="L1336" class="nb">1336</td><td>        #   &lt;tt&gt;has_many :subscribers, through: :subscriptions&lt;/tt&gt; will look for either &lt;tt&gt;:subscribers&lt;/tt&gt; or</td></tr><tr><td id="L1337" class="nb">1337</td><td>        #   &lt;tt&gt;:subscriber&lt;/tt&gt; on Subscription, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.</td></tr><tr><td id="L1338" class="nb">1338</td><td>        # [:source_type]</td></tr><tr><td id="L1339" class="nb">1339</td><td>        #   Specifies type of the source association used by #has_many &lt;tt&gt;:through&lt;/tt&gt; queries where the source</td></tr><tr><td id="L1340" class="nb">1340</td><td>        #   association is a polymorphic #belongs_to.</td></tr><tr><td id="L1341" class="nb">1341</td><td>        # [:validate]</td></tr><tr><td id="L1342" class="nb">1342</td><td>        #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.</td></tr><tr><td id="L1343" class="nb">1343</td><td>        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.</td></tr><tr><td id="L1344" class="nb">1344</td><td>        # [:autosave]</td></tr><tr><td id="L1345" class="nb">1345</td><td>        #   If true, always save the associated objects or destroy them if marked for destruction,</td></tr><tr><td id="L1346" class="nb">1346</td><td>        #   when saving the parent object. If false, never save or destroy the associated objects.</td></tr><tr><td id="L1347" class="nb">1347</td><td>        #   By default, only save associated objects that are new records. This option is implemented as a</td></tr><tr><td id="L1348" class="nb">1348</td><td>        #   +before_save+ callback. Because callbacks are run in the order they are defined, associated objects</td></tr><tr><td id="L1349" class="nb">1349</td><td>        #   may need to be explicitly saved in any user-defined +before_save+ callbacks.</td></tr><tr><td id="L1350" class="nb">1350</td><td>        #</td></tr><tr><td id="L1351" class="nb">1351</td><td>        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets</td></tr><tr><td id="L1352" class="nb">1352</td><td>        #   &lt;tt&gt;:autosave&lt;/tt&gt; to &lt;tt&gt;true&lt;/tt&gt;.</td></tr><tr><td id="L1353" class="nb">1353</td><td>        # [:inverse_of]</td></tr><tr><td id="L1354" class="nb">1354</td><td>        #   Specifies the name of the #belongs_to association on the associated object</td></tr><tr><td id="L1355" class="nb">1355</td><td>        #   that is the inverse of this #has_many association. Does not work in combination</td></tr><tr><td id="L1356" class="nb">1356</td><td>        #   with &lt;tt&gt;:through&lt;/tt&gt; or &lt;tt&gt;:as&lt;/tt&gt; options.</td></tr><tr><td id="L1357" class="nb">1357</td><td>        #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.</td></tr><tr><td id="L1358" class="nb">1358</td><td>        # [:extend]</td></tr><tr><td id="L1359" class="nb">1359</td><td>        #   Specifies a module or array of modules that will be extended into the association object returned.</td></tr><tr><td id="L1360" class="nb">1360</td><td>        #   Useful for defining methods on associations, especially when they should be shared between multiple</td></tr><tr><td id="L1361" class="nb">1361</td><td>        #   association objects.</td></tr><tr><td id="L1362" class="nb">1362</td><td>        #</td></tr><tr><td id="L1363" class="nb">1363</td><td>        # Option examples:</td></tr><tr><td id="L1364" class="nb">1364</td><td>        #   has_many :comments, -&gt; { order("posted_on") }</td></tr><tr><td id="L1365" class="nb">1365</td><td>        #   has_many :comments, -&gt; { includes(:author) }</td></tr><tr><td id="L1366" class="nb">1366</td><td>        #   has_many :people, -&gt; { where(deleted: false).order("name") }, class_name: "Person"</td></tr><tr><td id="L1367" class="nb">1367</td><td>        #   has_many :tracks, -&gt; { order("position") }, dependent: :destroy</td></tr><tr><td id="L1368" class="nb">1368</td><td>        #   has_many :comments, dependent: :nullify</td></tr><tr><td id="L1369" class="nb">1369</td><td>        #   has_many :tags, as: :taggable</td></tr><tr><td id="L1370" class="nb">1370</td><td>        #   has_many :reports, -&gt; { readonly }</td></tr><tr><td id="L1371" class="nb">1371</td><td>        #   has_many :subscribers, through: :subscriptions, source: :user</td></tr><tr><td id="L1372" class="nb">1372</td><td>        <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">has_many</span>(name, scope = <span class="node-nil kind-expression run" title="3313x">nil</span>, **options, &amp;extension)</td></tr><tr><td id="L1373" class="nb">1373</td><td>          <span class="node-lvasgn kind-name run" title="5139x">reflection</span> <span class="node-lvasgn kind-operator run" title="5139x">=</span> <span class="node-const kind-name run" title="5184x">Builder</span><span class="node-const kind-double_colon run" title="5184x">::</span><span class="node-const kind-name run" title="5184x">HasMany</span><span class="node-send kind-dot run" title="5184x">.</span><span class="node-send kind-selector_begin run" title="5184x">build</span>(<span class="node-self kind-expression run" title="5184x">self</span>, <span class="node-lvar kind-name run" title="5184x">name</span>, <span class="node-lvar kind-name run" title="5184x">scope</span>, <span class="node-lvar kind-name run" title="5184x">options</span>, <span class="node-block_pass kind-operator run" title="5184x">&amp;</span><span class="node-lvar kind-name run" title="5184x">extension</span>)</td></tr><tr><td id="L1374" class="nb">1374</td><td>          <span class="node-const kind-name run" title="5139x">Reflection</span><span class="node-send kind-dot run" title="5139x">.</span><span class="node-send kind-selector_begin run" title="5139x">add_reflection</span> <span class="node-self kind-expression run" title="5139x">self</span>, <span class="node-lvar kind-name run" title="5139x">name</span>, <span class="node-lvar kind-name run" title="5139x">reflection</span></td></tr><tr><td id="L1375" class="nb">1375</td><td>        end</td></tr><tr><td id="L1376" class="nb">1376</td><td></td></tr><tr><td id="L1377" class="nb">1377</td><td>        # Specifies a one-to-one association with another class. This method should only be used</td></tr><tr><td id="L1378" class="nb">1378</td><td>        # if the other class contains the foreign key. If the current class contains the foreign key,</td></tr><tr><td id="L1379" class="nb">1379</td><td>        # then you should use #belongs_to instead. See also ActiveRecord::Associations::ClassMethods's overview</td></tr><tr><td id="L1380" class="nb">1380</td><td>        # on when to use #has_one and when to use #belongs_to.</td></tr><tr><td id="L1381" class="nb">1381</td><td>        #</td></tr><tr><td id="L1382" class="nb">1382</td><td>        # The following methods for retrieval and query of a single associated object will be added:</td></tr><tr><td id="L1383" class="nb">1383</td><td>        #</td></tr><tr><td id="L1384" class="nb">1384</td><td>        # +association+ is a placeholder for the symbol passed as the +name+ argument, so</td></tr><tr><td id="L1385" class="nb">1385</td><td>        # &lt;tt&gt;has_one :manager&lt;/tt&gt; would add among others &lt;tt&gt;manager.nil?&lt;/tt&gt;.</td></tr><tr><td id="L1386" class="nb">1386</td><td>        #</td></tr><tr><td id="L1387" class="nb">1387</td><td>        # [association]</td></tr><tr><td id="L1388" class="nb">1388</td><td>        #   Returns the associated object. +nil+ is returned if none is found.</td></tr><tr><td id="L1389" class="nb">1389</td><td>        # [association=(associate)]</td></tr><tr><td id="L1390" class="nb">1390</td><td>        #   Assigns the associate object, extracts the primary key, sets it as the foreign key,</td></tr><tr><td id="L1391" class="nb">1391</td><td>        #   and saves the associate object. To avoid database inconsistencies, permanently deletes an existing</td></tr><tr><td id="L1392" class="nb">1392</td><td>        #   associated object when assigning a new one, even if the new one isn't saved to database.</td></tr><tr><td id="L1393" class="nb">1393</td><td>        # [build_association(attributes = {})]</td></tr><tr><td id="L1394" class="nb">1394</td><td>        #   Returns a new object of the associated type that has been instantiated</td></tr><tr><td id="L1395" class="nb">1395</td><td>        #   with +attributes+ and linked to this object through a foreign key, but has not</td></tr><tr><td id="L1396" class="nb">1396</td><td>        #   yet been saved.</td></tr><tr><td id="L1397" class="nb">1397</td><td>        # [create_association(attributes = {})]</td></tr><tr><td id="L1398" class="nb">1398</td><td>        #   Returns a new object of the associated type that has been instantiated</td></tr><tr><td id="L1399" class="nb">1399</td><td>        #   with +attributes+, linked to this object through a foreign key, and that</td></tr><tr><td id="L1400" class="nb">1400</td><td>        #   has already been saved (if it passed the validation).</td></tr><tr><td id="L1401" class="nb">1401</td><td>        # [create_association!(attributes = {})]</td></tr><tr><td id="L1402" class="nb">1402</td><td>        #   Does the same as &lt;tt&gt;create_association&lt;/tt&gt;, but raises ActiveRecord::RecordInvalid</td></tr><tr><td id="L1403" class="nb">1403</td><td>        #   if the record is invalid.</td></tr><tr><td id="L1404" class="nb">1404</td><td>        # [reload_association]</td></tr><tr><td id="L1405" class="nb">1405</td><td>        #   Returns the associated object, forcing a database read.</td></tr><tr><td id="L1406" class="nb">1406</td><td>        #</td></tr><tr><td id="L1407" class="nb">1407</td><td>        # === Example</td></tr><tr><td id="L1408" class="nb">1408</td><td>        #</td></tr><tr><td id="L1409" class="nb">1409</td><td>        # An Account class declares &lt;tt&gt;has_one :beneficiary&lt;/tt&gt;, which will add:</td></tr><tr><td id="L1410" class="nb">1410</td><td>        # * &lt;tt&gt;Account#beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.where(account_id: id).first&lt;/tt&gt;)</td></tr><tr><td id="L1411" class="nb">1411</td><td>        # * &lt;tt&gt;Account#beneficiary=(beneficiary)&lt;/tt&gt; (similar to &lt;tt&gt;beneficiary.account_id = account.id; beneficiary.save&lt;/tt&gt;)</td></tr><tr><td id="L1412" class="nb">1412</td><td>        # * &lt;tt&gt;Account#build_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.new("account_id" =&gt; id)&lt;/tt&gt;)</td></tr><tr><td id="L1413" class="nb">1413</td><td>        # * &lt;tt&gt;Account#create_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;b = Beneficiary.new("account_id" =&gt; id); b.save; b&lt;/tt&gt;)</td></tr><tr><td id="L1414" class="nb">1414</td><td>        # * &lt;tt&gt;Account#create_beneficiary!&lt;/tt&gt; (similar to &lt;tt&gt;b = Beneficiary.new("account_id" =&gt; id); b.save!; b&lt;/tt&gt;)</td></tr><tr><td id="L1415" class="nb">1415</td><td>        # * &lt;tt&gt;Account#reload_beneficiary&lt;/tt&gt;</td></tr><tr><td id="L1416" class="nb">1416</td><td>        #</td></tr><tr><td id="L1417" class="nb">1417</td><td>        # === Scopes</td></tr><tr><td id="L1418" class="nb">1418</td><td>        #</td></tr><tr><td id="L1419" class="nb">1419</td><td>        # You can pass a second argument +scope+ as a callable (i.e. proc or</td></tr><tr><td id="L1420" class="nb">1420</td><td>        # lambda) to retrieve a specific record or customize the generated query</td></tr><tr><td id="L1421" class="nb">1421</td><td>        # when you access the associated object.</td></tr><tr><td id="L1422" class="nb">1422</td><td>        #</td></tr><tr><td id="L1423" class="nb">1423</td><td>        # Scope examples:</td></tr><tr><td id="L1424" class="nb">1424</td><td>        #   has_one :author, -&gt; { where(comment_id: 1) }</td></tr><tr><td id="L1425" class="nb">1425</td><td>        #   has_one :employer, -&gt; { joins(:company) }</td></tr><tr><td id="L1426" class="nb">1426</td><td>        #   has_one :latest_post, -&gt;(blog) { where("created_at &gt; ?", blog.enabled_at) }</td></tr><tr><td id="L1427" class="nb">1427</td><td>        #</td></tr><tr><td id="L1428" class="nb">1428</td><td>        # === Options</td></tr><tr><td id="L1429" class="nb">1429</td><td>        #</td></tr><tr><td id="L1430" class="nb">1430</td><td>        # The declaration can also include an +options+ hash to specialize the behavior of the association.</td></tr><tr><td id="L1431" class="nb">1431</td><td>        #</td></tr><tr><td id="L1432" class="nb">1432</td><td>        # Options are:</td></tr><tr><td id="L1433" class="nb">1433</td><td>        # [:class_name]</td></tr><tr><td id="L1434" class="nb">1434</td><td>        #   Specify the class name of the association. Use it only if that name can't be inferred</td></tr><tr><td id="L1435" class="nb">1435</td><td>        #   from the association name. So &lt;tt&gt;has_one :manager&lt;/tt&gt; will by default be linked to the Manager class, but</td></tr><tr><td id="L1436" class="nb">1436</td><td>        #   if the real class name is Person, you'll have to specify it with this option.</td></tr><tr><td id="L1437" class="nb">1437</td><td>        # [:dependent]</td></tr><tr><td id="L1438" class="nb">1438</td><td>        #   Controls what happens to the associated object when</td></tr><tr><td id="L1439" class="nb">1439</td><td>        #   its owner is destroyed:</td></tr><tr><td id="L1440" class="nb">1440</td><td>        #</td></tr><tr><td id="L1441" class="nb">1441</td><td>        #   * &lt;tt&gt;:destroy&lt;/tt&gt; causes the associated object to also be destroyed</td></tr><tr><td id="L1442" class="nb">1442</td><td>        #   * &lt;tt&gt;:delete&lt;/tt&gt; causes the associated object to be deleted directly from the database (so callbacks will not execute)</td></tr><tr><td id="L1443" class="nb">1443</td><td>        #   * &lt;tt&gt;:nullify&lt;/tt&gt; causes the foreign key to be set to +NULL+. Callbacks are not executed.</td></tr><tr><td id="L1444" class="nb">1444</td><td>        #   * &lt;tt&gt;:restrict_with_exception&lt;/tt&gt; causes an exception to be raised if there is an associated record</td></tr><tr><td id="L1445" class="nb">1445</td><td>        #   * &lt;tt&gt;:restrict_with_error&lt;/tt&gt; causes an error to be added to the owner if there is an associated object</td></tr><tr><td id="L1446" class="nb">1446</td><td>        #</td></tr><tr><td id="L1447" class="nb">1447</td><td>        #   Note that &lt;tt&gt;:dependent&lt;/tt&gt; option is ignored when using &lt;tt&gt;:through&lt;/tt&gt; option.</td></tr><tr><td id="L1448" class="nb">1448</td><td>        # [:foreign_key]</td></tr><tr><td id="L1449" class="nb">1449</td><td>        #   Specify the foreign key used for the association. By default this is guessed to be the name</td></tr><tr><td id="L1450" class="nb">1450</td><td>        #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_one association</td></tr><tr><td id="L1451" class="nb">1451</td><td>        #   will use "person_id" as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.</td></tr><tr><td id="L1452" class="nb">1452</td><td>        # [:foreign_type]</td></tr><tr><td id="L1453" class="nb">1453</td><td>        #   Specify the column used to store the associated object's type, if this is a polymorphic</td></tr><tr><td id="L1454" class="nb">1454</td><td>        #   association. By default this is guessed to be the name of the polymorphic association</td></tr><tr><td id="L1455" class="nb">1455</td><td>        #   specified on "as" option with a "_type" suffix. So a class that defines a</td></tr><tr><td id="L1456" class="nb">1456</td><td>        #   &lt;tt&gt;has_one :tag, as: :taggable&lt;/tt&gt; association will use "taggable_type" as the</td></tr><tr><td id="L1457" class="nb">1457</td><td>        #   default &lt;tt&gt;:foreign_type&lt;/tt&gt;.</td></tr><tr><td id="L1458" class="nb">1458</td><td>        # [:primary_key]</td></tr><tr><td id="L1459" class="nb">1459</td><td>        #   Specify the method that returns the primary key used for the association. By default this is +id+.</td></tr><tr><td id="L1460" class="nb">1460</td><td>        # [:as]</td></tr><tr><td id="L1461" class="nb">1461</td><td>        #   Specifies a polymorphic interface (See #belongs_to).</td></tr><tr><td id="L1462" class="nb">1462</td><td>        # [:through]</td></tr><tr><td id="L1463" class="nb">1463</td><td>        #   Specifies a Join Model through which to perform the query. Options for &lt;tt&gt;:class_name&lt;/tt&gt;,</td></tr><tr><td id="L1464" class="nb">1464</td><td>        #   &lt;tt&gt;:primary_key&lt;/tt&gt;, and &lt;tt&gt;:foreign_key&lt;/tt&gt; are ignored, as the association uses the</td></tr><tr><td id="L1465" class="nb">1465</td><td>        #   source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a #has_one</td></tr><tr><td id="L1466" class="nb">1466</td><td>        #   or #belongs_to association on the join model.</td></tr><tr><td id="L1467" class="nb">1467</td><td>        # [:source]</td></tr><tr><td id="L1468" class="nb">1468</td><td>        #   Specifies the source association name used by #has_one &lt;tt&gt;:through&lt;/tt&gt; queries.</td></tr><tr><td id="L1469" class="nb">1469</td><td>        #   Only use it if the name cannot be inferred from the association.</td></tr><tr><td id="L1470" class="nb">1470</td><td>        #   &lt;tt&gt;has_one :favorite, through: :favorites&lt;/tt&gt; will look for a</td></tr><tr><td id="L1471" class="nb">1471</td><td>        #   &lt;tt&gt;:favorite&lt;/tt&gt; on Favorite, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.</td></tr><tr><td id="L1472" class="nb">1472</td><td>        # [:source_type]</td></tr><tr><td id="L1473" class="nb">1473</td><td>        #   Specifies type of the source association used by #has_one &lt;tt&gt;:through&lt;/tt&gt; queries where the source</td></tr><tr><td id="L1474" class="nb">1474</td><td>        #   association is a polymorphic #belongs_to.</td></tr><tr><td id="L1475" class="nb">1475</td><td>        # [:validate]</td></tr><tr><td id="L1476" class="nb">1476</td><td>        #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.</td></tr><tr><td id="L1477" class="nb">1477</td><td>        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.</td></tr><tr><td id="L1478" class="nb">1478</td><td>        # [:autosave]</td></tr><tr><td id="L1479" class="nb">1479</td><td>        #   If true, always save the associated object or destroy it if marked for destruction,</td></tr><tr><td id="L1480" class="nb">1480</td><td>        #   when saving the parent object. If false, never save or destroy the associated object.</td></tr><tr><td id="L1481" class="nb">1481</td><td>        #   By default, only save the associated object if it's a new record.</td></tr><tr><td id="L1482" class="nb">1482</td><td>        #</td></tr><tr><td id="L1483" class="nb">1483</td><td>        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets</td></tr><tr><td id="L1484" class="nb">1484</td><td>        #   &lt;tt&gt;:autosave&lt;/tt&gt; to &lt;tt&gt;true&lt;/tt&gt;.</td></tr><tr><td id="L1485" class="nb">1485</td><td>        # [:inverse_of]</td></tr><tr><td id="L1486" class="nb">1486</td><td>        #   Specifies the name of the #belongs_to association on the associated object</td></tr><tr><td id="L1487" class="nb">1487</td><td>        #   that is the inverse of this #has_one association. Does not work in combination</td></tr><tr><td id="L1488" class="nb">1488</td><td>        #   with &lt;tt&gt;:through&lt;/tt&gt; or &lt;tt&gt;:as&lt;/tt&gt; options.</td></tr><tr><td id="L1489" class="nb">1489</td><td>        #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.</td></tr><tr><td id="L1490" class="nb">1490</td><td>        # [:required]</td></tr><tr><td id="L1491" class="nb">1491</td><td>        #   When set to +true+, the association will also have its presence validated.</td></tr><tr><td id="L1492" class="nb">1492</td><td>        #   This will validate the association itself, not the id. You can use</td></tr><tr><td id="L1493" class="nb">1493</td><td>        #   +:inverse_of+ to avoid an extra query during validation.</td></tr><tr><td id="L1494" class="nb">1494</td><td>        #</td></tr><tr><td id="L1495" class="nb">1495</td><td>        # Option examples:</td></tr><tr><td id="L1496" class="nb">1496</td><td>        #   has_one :credit_card, dependent: :destroy  # destroys the associated credit card</td></tr><tr><td id="L1497" class="nb">1497</td><td>        #   has_one :credit_card, dependent: :nullify  # updates the associated records foreign</td></tr><tr><td id="L1498" class="nb">1498</td><td>        #                                                 # key value to NULL rather than destroying it</td></tr><tr><td id="L1499" class="nb">1499</td><td>        #   has_one :last_comment, -&gt; { order('posted_on') }, class_name: "Comment"</td></tr><tr><td id="L1500" class="nb">1500</td><td>        #   has_one :project_manager, -&gt; { where(role: 'project_manager') }, class_name: "Person"</td></tr><tr><td id="L1501" class="nb">1501</td><td>        #   has_one :attachment, as: :attachable</td></tr><tr><td id="L1502" class="nb">1502</td><td>        #   has_one :boss, -&gt; { readonly }</td></tr><tr><td id="L1503" class="nb">1503</td><td>        #   has_one :club, through: :membership</td></tr><tr><td id="L1504" class="nb">1504</td><td>        #   has_one :primary_address, -&gt; { where(primary: true) }, through: :addressables, source: :addressable</td></tr><tr><td id="L1505" class="nb">1505</td><td>        #   has_one :credit_card, required: true</td></tr><tr><td id="L1506" class="nb">1506</td><td>        <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">has_one</span>(name, scope = <span class="node-nil kind-expression run" title="1023x">nil</span>, **options)</td></tr><tr><td id="L1507" class="nb">1507</td><td>          <span class="node-lvasgn kind-name run" title="1210x">reflection</span> <span class="node-lvasgn kind-operator run" title="1210x">=</span> <span class="node-const kind-name run" title="1242x">Builder</span><span class="node-const kind-double_colon run" title="1242x">::</span><span class="node-const kind-name run" title="1242x">HasOne</span><span class="node-send kind-dot run" title="1242x">.</span><span class="node-send kind-selector_begin run" title="1242x">build</span>(<span class="node-self kind-expression run" title="1242x">self</span>, <span class="node-lvar kind-name run" title="1242x">name</span>, <span class="node-lvar kind-name run" title="1242x">scope</span>, <span class="node-lvar kind-name run" title="1242x">options</span>)</td></tr><tr><td id="L1508" class="nb">1508</td><td>          <span class="node-const kind-name run" title="1210x">Reflection</span><span class="node-send kind-dot run" title="1210x">.</span><span class="node-send kind-selector_begin run" title="1210x">add_reflection</span> <span class="node-self kind-expression run" title="1210x">self</span>, <span class="node-lvar kind-name run" title="1210x">name</span>, <span class="node-lvar kind-name run" title="1210x">reflection</span></td></tr><tr><td id="L1509" class="nb">1509</td><td>        end</td></tr><tr><td id="L1510" class="nb">1510</td><td></td></tr><tr><td id="L1511" class="nb">1511</td><td>        # Specifies a one-to-one association with another class. This method should only be used</td></tr><tr><td id="L1512" class="nb">1512</td><td>        # if this class contains the foreign key. If the other class contains the foreign key,</td></tr><tr><td id="L1513" class="nb">1513</td><td>        # then you should use #has_one instead. See also ActiveRecord::Associations::ClassMethods's overview</td></tr><tr><td id="L1514" class="nb">1514</td><td>        # on when to use #has_one and when to use #belongs_to.</td></tr><tr><td id="L1515" class="nb">1515</td><td>        #</td></tr><tr><td id="L1516" class="nb">1516</td><td>        # Methods will be added for retrieval and query for a single associated object, for which</td></tr><tr><td id="L1517" class="nb">1517</td><td>        # this object holds an id:</td></tr><tr><td id="L1518" class="nb">1518</td><td>        #</td></tr><tr><td id="L1519" class="nb">1519</td><td>        # +association+ is a placeholder for the symbol passed as the +name+ argument, so</td></tr><tr><td id="L1520" class="nb">1520</td><td>        # &lt;tt&gt;belongs_to :author&lt;/tt&gt; would add among others &lt;tt&gt;author.nil?&lt;/tt&gt;.</td></tr><tr><td id="L1521" class="nb">1521</td><td>        #</td></tr><tr><td id="L1522" class="nb">1522</td><td>        # [association]</td></tr><tr><td id="L1523" class="nb">1523</td><td>        #   Returns the associated object. +nil+ is returned if none is found.</td></tr><tr><td id="L1524" class="nb">1524</td><td>        # [association=(associate)]</td></tr><tr><td id="L1525" class="nb">1525</td><td>        #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.</td></tr><tr><td id="L1526" class="nb">1526</td><td>        # [build_association(attributes = {})]</td></tr><tr><td id="L1527" class="nb">1527</td><td>        #   Returns a new object of the associated type that has been instantiated</td></tr><tr><td id="L1528" class="nb">1528</td><td>        #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.</td></tr><tr><td id="L1529" class="nb">1529</td><td>        # [create_association(attributes = {})]</td></tr><tr><td id="L1530" class="nb">1530</td><td>        #   Returns a new object of the associated type that has been instantiated</td></tr><tr><td id="L1531" class="nb">1531</td><td>        #   with +attributes+, linked to this object through a foreign key, and that</td></tr><tr><td id="L1532" class="nb">1532</td><td>        #   has already been saved (if it passed the validation).</td></tr><tr><td id="L1533" class="nb">1533</td><td>        # [create_association!(attributes = {})]</td></tr><tr><td id="L1534" class="nb">1534</td><td>        #   Does the same as &lt;tt&gt;create_association&lt;/tt&gt;, but raises ActiveRecord::RecordInvalid</td></tr><tr><td id="L1535" class="nb">1535</td><td>        #   if the record is invalid.</td></tr><tr><td id="L1536" class="nb">1536</td><td>        # [reload_association]</td></tr><tr><td id="L1537" class="nb">1537</td><td>        #   Returns the associated object, forcing a database read.</td></tr><tr><td id="L1538" class="nb">1538</td><td>        #</td></tr><tr><td id="L1539" class="nb">1539</td><td>        # === Example</td></tr><tr><td id="L1540" class="nb">1540</td><td>        #</td></tr><tr><td id="L1541" class="nb">1541</td><td>        # A Post class declares &lt;tt&gt;belongs_to :author&lt;/tt&gt;, which will add:</td></tr><tr><td id="L1542" class="nb">1542</td><td>        # * &lt;tt&gt;Post#author&lt;/tt&gt; (similar to &lt;tt&gt;Author.find(author_id)&lt;/tt&gt;)</td></tr><tr><td id="L1543" class="nb">1543</td><td>        # * &lt;tt&gt;Post#author=(author)&lt;/tt&gt; (similar to &lt;tt&gt;post.author_id = author.id&lt;/tt&gt;)</td></tr><tr><td id="L1544" class="nb">1544</td><td>        # * &lt;tt&gt;Post#build_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new&lt;/tt&gt;)</td></tr><tr><td id="L1545" class="nb">1545</td><td>        # * &lt;tt&gt;Post#create_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new; post.author.save; post.author&lt;/tt&gt;)</td></tr><tr><td id="L1546" class="nb">1546</td><td>        # * &lt;tt&gt;Post#create_author!&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new; post.author.save!; post.author&lt;/tt&gt;)</td></tr><tr><td id="L1547" class="nb">1547</td><td>        # * &lt;tt&gt;Post#reload_author&lt;/tt&gt;</td></tr><tr><td id="L1548" class="nb">1548</td><td>        # The declaration can also include an +options+ hash to specialize the behavior of the association.</td></tr><tr><td id="L1549" class="nb">1549</td><td>        #</td></tr><tr><td id="L1550" class="nb">1550</td><td>        # === Scopes</td></tr><tr><td id="L1551" class="nb">1551</td><td>        #</td></tr><tr><td id="L1552" class="nb">1552</td><td>        # You can pass a second argument +scope+ as a callable (i.e. proc or</td></tr><tr><td id="L1553" class="nb">1553</td><td>        # lambda) to retrieve a specific record or customize the generated query</td></tr><tr><td id="L1554" class="nb">1554</td><td>        # when you access the associated object.</td></tr><tr><td id="L1555" class="nb">1555</td><td>        #</td></tr><tr><td id="L1556" class="nb">1556</td><td>        # Scope examples:</td></tr><tr><td id="L1557" class="nb">1557</td><td>        #   belongs_to :firm, -&gt; { where(id: 2) }</td></tr><tr><td id="L1558" class="nb">1558</td><td>        #   belongs_to :user, -&gt; { joins(:friends) }</td></tr><tr><td id="L1559" class="nb">1559</td><td>        #   belongs_to :level, -&gt;(game) { where("game_level &gt; ?", game.current_level) }</td></tr><tr><td id="L1560" class="nb">1560</td><td>        #</td></tr><tr><td id="L1561" class="nb">1561</td><td>        # === Options</td></tr><tr><td id="L1562" class="nb">1562</td><td>        #</td></tr><tr><td id="L1563" class="nb">1563</td><td>        # [:class_name]</td></tr><tr><td id="L1564" class="nb">1564</td><td>        #   Specify the class name of the association. Use it only if that name can't be inferred</td></tr><tr><td id="L1565" class="nb">1565</td><td>        #   from the association name. So &lt;tt&gt;belongs_to :author&lt;/tt&gt; will by default be linked to the Author class, but</td></tr><tr><td id="L1566" class="nb">1566</td><td>        #   if the real class name is Person, you'll have to specify it with this option.</td></tr><tr><td id="L1567" class="nb">1567</td><td>        # [:foreign_key]</td></tr><tr><td id="L1568" class="nb">1568</td><td>        #   Specify the foreign key used for the association. By default this is guessed to be the name</td></tr><tr><td id="L1569" class="nb">1569</td><td>        #   of the association with an "_id" suffix. So a class that defines a &lt;tt&gt;belongs_to :person&lt;/tt&gt;</td></tr><tr><td id="L1570" class="nb">1570</td><td>        #   association will use "person_id" as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;. Similarly,</td></tr><tr><td id="L1571" class="nb">1571</td><td>        #   &lt;tt&gt;belongs_to :favorite_person, class_name: "Person"&lt;/tt&gt; will use a foreign key</td></tr><tr><td id="L1572" class="nb">1572</td><td>        #   of "favorite_person_id".</td></tr><tr><td id="L1573" class="nb">1573</td><td>        # [:foreign_type]</td></tr><tr><td id="L1574" class="nb">1574</td><td>        #   Specify the column used to store the associated object's type, if this is a polymorphic</td></tr><tr><td id="L1575" class="nb">1575</td><td>        #   association. By default this is guessed to be the name of the association with a "_type"</td></tr><tr><td id="L1576" class="nb">1576</td><td>        #   suffix. So a class that defines a &lt;tt&gt;belongs_to :taggable, polymorphic: true&lt;/tt&gt;</td></tr><tr><td id="L1577" class="nb">1577</td><td>        #   association will use "taggable_type" as the default &lt;tt&gt;:foreign_type&lt;/tt&gt;.</td></tr><tr><td id="L1578" class="nb">1578</td><td>        # [:primary_key]</td></tr><tr><td id="L1579" class="nb">1579</td><td>        #   Specify the method that returns the primary key of associated object used for the association.</td></tr><tr><td id="L1580" class="nb">1580</td><td>        #   By default this is id.</td></tr><tr><td id="L1581" class="nb">1581</td><td>        # [:dependent]</td></tr><tr><td id="L1582" class="nb">1582</td><td>        #   If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to</td></tr><tr><td id="L1583" class="nb">1583</td><td>        #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method.</td></tr><tr><td id="L1584" class="nb">1584</td><td>        #   This option should not be specified when #belongs_to is used in conjunction with</td></tr><tr><td id="L1585" class="nb">1585</td><td>        #   a #has_many relationship on another class because of the potential to leave</td></tr><tr><td id="L1586" class="nb">1586</td><td>        #   orphaned records behind.</td></tr><tr><td id="L1587" class="nb">1587</td><td>        # [:counter_cache]</td></tr><tr><td id="L1588" class="nb">1588</td><td>        #   Caches the number of belonging objects on the associate class through the use of CounterCache::ClassMethods#increment_counter</td></tr><tr><td id="L1589" class="nb">1589</td><td>        #   and CounterCache::ClassMethods#decrement_counter. The counter cache is incremented when an object of this</td></tr><tr><td id="L1590" class="nb">1590</td><td>        #   class is created and decremented when it's destroyed. This requires that a column</td></tr><tr><td id="L1591" class="nb">1591</td><td>        #   named &lt;tt&gt;#{table_name}_count&lt;/tt&gt; (such as +comments_count+ for a belonging Comment class)</td></tr><tr><td id="L1592" class="nb">1592</td><td>        #   is used on the associate class (such as a Post class) - that is the migration for</td></tr><tr><td id="L1593" class="nb">1593</td><td>        #   &lt;tt&gt;#{table_name}_count&lt;/tt&gt; is created on the associate class (such that &lt;tt&gt;Post.comments_count&lt;/tt&gt; will</td></tr><tr><td id="L1594" class="nb">1594</td><td>        #   return the count cached, see note below). You can also specify a custom counter</td></tr><tr><td id="L1595" class="nb">1595</td><td>        #   cache column by providing a column name instead of a +true+/+false+ value to this</td></tr><tr><td id="L1596" class="nb">1596</td><td>        #   option (e.g., &lt;tt&gt;counter_cache: :my_custom_counter&lt;/tt&gt;.)</td></tr><tr><td id="L1597" class="nb">1597</td><td>        #   Note: Specifying a counter cache will add it to that model's list of readonly attributes</td></tr><tr><td id="L1598" class="nb">1598</td><td>        #   using +attr_readonly+.</td></tr><tr><td id="L1599" class="nb">1599</td><td>        # [:polymorphic]</td></tr><tr><td id="L1600" class="nb">1600</td><td>        #   Specify this association is a polymorphic association by passing +true+.</td></tr><tr><td id="L1601" class="nb">1601</td><td>        #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute</td></tr><tr><td id="L1602" class="nb">1602</td><td>        #   to the +attr_readonly+ list in the associated classes (e.g. &lt;tt&gt;class Post; attr_readonly :comments_count; end&lt;/tt&gt;).</td></tr><tr><td id="L1603" class="nb">1603</td><td>        # [:validate]</td></tr><tr><td id="L1604" class="nb">1604</td><td>        #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.</td></tr><tr><td id="L1605" class="nb">1605</td><td>        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.</td></tr><tr><td id="L1606" class="nb">1606</td><td>        # [:autosave]</td></tr><tr><td id="L1607" class="nb">1607</td><td>        #   If true, always save the associated object or destroy it if marked for destruction, when</td></tr><tr><td id="L1608" class="nb">1608</td><td>        #   saving the parent object.</td></tr><tr><td id="L1609" class="nb">1609</td><td>        #   If false, never save or destroy the associated object.</td></tr><tr><td id="L1610" class="nb">1610</td><td>        #   By default, only save the associated object if it's a new record.</td></tr><tr><td id="L1611" class="nb">1611</td><td>        #</td></tr><tr><td id="L1612" class="nb">1612</td><td>        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for</td></tr><tr><td id="L1613" class="nb">1613</td><td>        #   sets &lt;tt&gt;:autosave&lt;/tt&gt; to &lt;tt&gt;true&lt;/tt&gt;.</td></tr><tr><td id="L1614" class="nb">1614</td><td>        # [:touch]</td></tr><tr><td id="L1615" class="nb">1615</td><td>        #   If true, the associated object will be touched (the updated_at/on attributes set to current time)</td></tr><tr><td id="L1616" class="nb">1616</td><td>        #   when this record is either saved or destroyed. If you specify a symbol, that attribute</td></tr><tr><td id="L1617" class="nb">1617</td><td>        #   will be updated with the current time in addition to the updated_at/on attribute.</td></tr><tr><td id="L1618" class="nb">1618</td><td>        #   Please note that with touching no validation is performed and only the +after_touch+,</td></tr><tr><td id="L1619" class="nb">1619</td><td>        #   +after_commit+ and +after_rollback+ callbacks are executed.</td></tr><tr><td id="L1620" class="nb">1620</td><td>        # [:inverse_of]</td></tr><tr><td id="L1621" class="nb">1621</td><td>        #   Specifies the name of the #has_one or #has_many association on the associated</td></tr><tr><td id="L1622" class="nb">1622</td><td>        #   object that is the inverse of this #belongs_to association. Does not work in</td></tr><tr><td id="L1623" class="nb">1623</td><td>        #   combination with the &lt;tt&gt;:polymorphic&lt;/tt&gt; options.</td></tr><tr><td id="L1624" class="nb">1624</td><td>        #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.</td></tr><tr><td id="L1625" class="nb">1625</td><td>        # [:optional]</td></tr><tr><td id="L1626" class="nb">1626</td><td>        #   When set to +true+, the association will not have its presence validated.</td></tr><tr><td id="L1627" class="nb">1627</td><td>        # [:required]</td></tr><tr><td id="L1628" class="nb">1628</td><td>        #   When set to +true+, the association will also have its presence validated.</td></tr><tr><td id="L1629" class="nb">1629</td><td>        #   This will validate the association itself, not the id. You can use</td></tr><tr><td id="L1630" class="nb">1630</td><td>        #   +:inverse_of+ to avoid an extra query during validation.</td></tr><tr><td id="L1631" class="nb">1631</td><td>        #   NOTE: &lt;tt&gt;required&lt;/tt&gt; is set to &lt;tt&gt;true&lt;/tt&gt; by default and is deprecated. If</td></tr><tr><td id="L1632" class="nb">1632</td><td>        #   you don't want to have association presence validated, use &lt;tt&gt;optional: true&lt;/tt&gt;.</td></tr><tr><td id="L1633" class="nb">1633</td><td>        # [:default]</td></tr><tr><td id="L1634" class="nb">1634</td><td>        #   Provide a callable (i.e. proc or lambda) to specify that the association should</td></tr><tr><td id="L1635" class="nb">1635</td><td>        #   be initialized with a particular record before validation.</td></tr><tr><td id="L1636" class="nb">1636</td><td>        #</td></tr><tr><td id="L1637" class="nb">1637</td><td>        # Option examples:</td></tr><tr><td id="L1638" class="nb">1638</td><td>        #   belongs_to :firm, foreign_key: "client_of"</td></tr><tr><td id="L1639" class="nb">1639</td><td>        #   belongs_to :person, primary_key: "name", foreign_key: "person_name"</td></tr><tr><td id="L1640" class="nb">1640</td><td>        #   belongs_to :author, class_name: "Person", foreign_key: "author_id"</td></tr><tr><td id="L1641" class="nb">1641</td><td>        #   belongs_to :valid_coupon, -&gt;(o) { where "discounts &gt; ?", o.payments_count },</td></tr><tr><td id="L1642" class="nb">1642</td><td>        #                             class_name: "Coupon", foreign_key: "coupon_id"</td></tr><tr><td id="L1643" class="nb">1643</td><td>        #   belongs_to :attachable, polymorphic: true</td></tr><tr><td id="L1644" class="nb">1644</td><td>        #   belongs_to :project, -&gt; { readonly }</td></tr><tr><td id="L1645" class="nb">1645</td><td>        #   belongs_to :post, counter_cache: true</td></tr><tr><td id="L1646" class="nb">1646</td><td>        #   belongs_to :comment, touch: true</td></tr><tr><td id="L1647" class="nb">1647</td><td>        #   belongs_to :company, touch: :employees_last_updated_at</td></tr><tr><td id="L1648" class="nb">1648</td><td>        #   belongs_to :user, optional: true</td></tr><tr><td id="L1649" class="nb">1649</td><td>        #   belongs_to :account, default: -&gt; { company.account }</td></tr><tr><td id="L1650" class="nb">1650</td><td>        <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">belongs_to</span>(name, scope = <span class="node-nil kind-expression run" title="4084x">nil</span>, **options)</td></tr><tr><td id="L1651" class="nb">1651</td><td>          <span class="node-lvasgn kind-name run" title="4167x">reflection</span> <span class="node-lvasgn kind-operator run" title="4167x">=</span> <span class="node-const kind-name run" title="4216x">Builder</span><span class="node-const kind-double_colon run" title="4216x">::</span><span class="node-const kind-name run" title="4216x">BelongsTo</span><span class="node-send kind-dot run" title="4216x">.</span><span class="node-send kind-selector_begin run" title="4216x">build</span>(<span class="node-self kind-expression run" title="4216x">self</span>, <span class="node-lvar kind-name run" title="4216x">name</span>, <span class="node-lvar kind-name run" title="4216x">scope</span>, <span class="node-lvar kind-name run" title="4216x">options</span>)</td></tr><tr><td id="L1652" class="nb">1652</td><td>          <span class="node-const kind-name run" title="4167x">Reflection</span><span class="node-send kind-dot run" title="4167x">.</span><span class="node-send kind-selector_begin run" title="4167x">add_reflection</span> <span class="node-self kind-expression run" title="4167x">self</span>, <span class="node-lvar kind-name run" title="4167x">name</span>, <span class="node-lvar kind-name run" title="4167x">reflection</span></td></tr><tr><td id="L1653" class="nb">1653</td><td>        end</td></tr><tr><td id="L1654" class="nb">1654</td><td></td></tr><tr><td id="L1655" class="nb">1655</td><td>        # Specifies a many-to-many relationship with another class. This associates two classes via an</td></tr><tr><td id="L1656" class="nb">1656</td><td>        # intermediate join table. Unless the join table is explicitly specified as an option, it is</td></tr><tr><td id="L1657" class="nb">1657</td><td>        # guessed using the lexical order of the class names. So a join between Developer and Project</td></tr><tr><td id="L1658" class="nb">1658</td><td>        # will give the default join table name of "developers_projects" because "D" precedes "P" alphabetically.</td></tr><tr><td id="L1659" class="nb">1659</td><td>        # Note that this precedence is calculated using the &lt;tt&gt;&lt;&lt;/tt&gt; operator for String. This</td></tr><tr><td id="L1660" class="nb">1660</td><td>        # means that if the strings are of different lengths, and the strings are equal when compared</td></tr><tr><td id="L1661" class="nb">1661</td><td>        # up to the shortest length, then the longer string is considered of higher</td></tr><tr><td id="L1662" class="nb">1662</td><td>        # lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers"</td></tr><tr><td id="L1663" class="nb">1663</td><td>        # to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes",</td></tr><tr><td id="L1664" class="nb">1664</td><td>        # but it in fact generates a join table name of "paper_boxes_papers". Be aware of this caveat, and use the</td></tr><tr><td id="L1665" class="nb">1665</td><td>        # custom &lt;tt&gt;:join_table&lt;/tt&gt; option if you need to.</td></tr><tr><td id="L1666" class="nb">1666</td><td>        # If your tables share a common prefix, it will only appear once at the beginning. For example,</td></tr><tr><td id="L1667" class="nb">1667</td><td>        # the tables "catalog_categories" and "catalog_products" generate a join table name of "catalog_categories_products".</td></tr><tr><td id="L1668" class="nb">1668</td><td>        #</td></tr><tr><td id="L1669" class="nb">1669</td><td>        # The join table should not have a primary key or a model associated with it. You must manually generate the</td></tr><tr><td id="L1670" class="nb">1670</td><td>        # join table with a migration such as this:</td></tr><tr><td id="L1671" class="nb">1671</td><td>        #</td></tr><tr><td id="L1672" class="nb">1672</td><td>        #   class CreateDevelopersProjectsJoinTable &lt; ActiveRecord::Migration[5.0]</td></tr><tr><td id="L1673" class="nb">1673</td><td>        #     def change</td></tr><tr><td id="L1674" class="nb">1674</td><td>        #       create_join_table :developers, :projects</td></tr><tr><td id="L1675" class="nb">1675</td><td>        #     end</td></tr><tr><td id="L1676" class="nb">1676</td><td>        #   end</td></tr><tr><td id="L1677" class="nb">1677</td><td>        #</td></tr><tr><td id="L1678" class="nb">1678</td><td>        # It's also a good idea to add indexes to each of those columns to speed up the joins process.</td></tr><tr><td id="L1679" class="nb">1679</td><td>        # However, in MySQL it is advised to add a compound index for both of the columns as MySQL only</td></tr><tr><td id="L1680" class="nb">1680</td><td>        # uses one index per table during the lookup.</td></tr><tr><td id="L1681" class="nb">1681</td><td>        #</td></tr><tr><td id="L1682" class="nb">1682</td><td>        # Adds the following methods for retrieval and query:</td></tr><tr><td id="L1683" class="nb">1683</td><td>        #</td></tr><tr><td id="L1684" class="nb">1684</td><td>        # +collection+ is a placeholder for the symbol passed as the +name+ argument, so</td></tr><tr><td id="L1685" class="nb">1685</td><td>        # &lt;tt&gt;has_and_belongs_to_many :categories&lt;/tt&gt; would add among others &lt;tt&gt;categories.empty?&lt;/tt&gt;.</td></tr><tr><td id="L1686" class="nb">1686</td><td>        #</td></tr><tr><td id="L1687" class="nb">1687</td><td>        # [collection]</td></tr><tr><td id="L1688" class="nb">1688</td><td>        #   Returns a Relation of all the associated objects.</td></tr><tr><td id="L1689" class="nb">1689</td><td>        #   An empty Relation is returned if none are found.</td></tr><tr><td id="L1690" class="nb">1690</td><td>        # [collection&lt;&lt;(object, ...)]</td></tr><tr><td id="L1691" class="nb">1691</td><td>        #   Adds one or more objects to the collection by creating associations in the join table</td></tr><tr><td id="L1692" class="nb">1692</td><td>        #   (&lt;tt&gt;collection.push&lt;/tt&gt; and &lt;tt&gt;collection.concat&lt;/tt&gt; are aliases to this method).</td></tr><tr><td id="L1693" class="nb">1693</td><td>        #   Note that this operation instantly fires update SQL without waiting for the save or update call on the</td></tr><tr><td id="L1694" class="nb">1694</td><td>        #   parent object, unless the parent object is a new record.</td></tr><tr><td id="L1695" class="nb">1695</td><td>        # [collection.delete(object, ...)]</td></tr><tr><td id="L1696" class="nb">1696</td><td>        #   Removes one or more objects from the collection by removing their associations from the join table.</td></tr><tr><td id="L1697" class="nb">1697</td><td>        #   This does not destroy the objects.</td></tr><tr><td id="L1698" class="nb">1698</td><td>        # [collection.destroy(object, ...)]</td></tr><tr><td id="L1699" class="nb">1699</td><td>        #   Removes one or more objects from the collection by running destroy on each association in the join table, overriding any dependent option.</td></tr><tr><td id="L1700" class="nb">1700</td><td>        #   This does not destroy the objects.</td></tr><tr><td id="L1701" class="nb">1701</td><td>        # [collection=objects]</td></tr><tr><td id="L1702" class="nb">1702</td><td>        #   Replaces the collection's content by deleting and adding objects as appropriate.</td></tr><tr><td id="L1703" class="nb">1703</td><td>        # [collection_singular_ids]</td></tr><tr><td id="L1704" class="nb">1704</td><td>        #   Returns an array of the associated objects' ids.</td></tr><tr><td id="L1705" class="nb">1705</td><td>        # [collection_singular_ids=ids]</td></tr><tr><td id="L1706" class="nb">1706</td><td>        #   Replace the collection by the objects identified by the primary keys in +ids+.</td></tr><tr><td id="L1707" class="nb">1707</td><td>        # [collection.clear]</td></tr><tr><td id="L1708" class="nb">1708</td><td>        #   Removes every object from the collection. This does not destroy the objects.</td></tr><tr><td id="L1709" class="nb">1709</td><td>        # [collection.empty?]</td></tr><tr><td id="L1710" class="nb">1710</td><td>        #   Returns +true+ if there are no associated objects.</td></tr><tr><td id="L1711" class="nb">1711</td><td>        # [collection.size]</td></tr><tr><td id="L1712" class="nb">1712</td><td>        #   Returns the number of associated objects.</td></tr><tr><td id="L1713" class="nb">1713</td><td>        # [collection.find(id)]</td></tr><tr><td id="L1714" class="nb">1714</td><td>        #   Finds an associated object responding to the +id+ and that</td></tr><tr><td id="L1715" class="nb">1715</td><td>        #   meets the condition that it has to be associated with this object.</td></tr><tr><td id="L1716" class="nb">1716</td><td>        #   Uses the same rules as ActiveRecord::FinderMethods#find.</td></tr><tr><td id="L1717" class="nb">1717</td><td>        # [collection.exists?(...)]</td></tr><tr><td id="L1718" class="nb">1718</td><td>        #   Checks whether an associated object with the given conditions exists.</td></tr><tr><td id="L1719" class="nb">1719</td><td>        #   Uses the same rules as ActiveRecord::FinderMethods#exists?.</td></tr><tr><td id="L1720" class="nb">1720</td><td>        # [collection.build(attributes = {})]</td></tr><tr><td id="L1721" class="nb">1721</td><td>        #   Returns a new object of the collection type that has been instantiated</td></tr><tr><td id="L1722" class="nb">1722</td><td>        #   with +attributes+ and linked to this object through the join table, but has not yet been saved.</td></tr><tr><td id="L1723" class="nb">1723</td><td>        # [collection.create(attributes = {})]</td></tr><tr><td id="L1724" class="nb">1724</td><td>        #   Returns a new object of the collection type that has been instantiated</td></tr><tr><td id="L1725" class="nb">1725</td><td>        #   with +attributes+, linked to this object through the join table, and that has already been</td></tr><tr><td id="L1726" class="nb">1726</td><td>        #   saved (if it passed the validation).</td></tr><tr><td id="L1727" class="nb">1727</td><td>        # [collection.reload]</td></tr><tr><td id="L1728" class="nb">1728</td><td>        #   Returns a Relation of all of the associated objects, forcing a database read.</td></tr><tr><td id="L1729" class="nb">1729</td><td>        #   An empty Relation is returned if none are found.</td></tr><tr><td id="L1730" class="nb">1730</td><td>        #</td></tr><tr><td id="L1731" class="nb">1731</td><td>        # === Example</td></tr><tr><td id="L1732" class="nb">1732</td><td>        #</td></tr><tr><td id="L1733" class="nb">1733</td><td>        # A Developer class declares &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt;, which will add:</td></tr><tr><td id="L1734" class="nb">1734</td><td>        # * &lt;tt&gt;Developer#projects&lt;/tt&gt;</td></tr><tr><td id="L1735" class="nb">1735</td><td>        # * &lt;tt&gt;Developer#projects&lt;&lt;&lt;/tt&gt;</td></tr><tr><td id="L1736" class="nb">1736</td><td>        # * &lt;tt&gt;Developer#projects.delete&lt;/tt&gt;</td></tr><tr><td id="L1737" class="nb">1737</td><td>        # * &lt;tt&gt;Developer#projects.destroy&lt;/tt&gt;</td></tr><tr><td id="L1738" class="nb">1738</td><td>        # * &lt;tt&gt;Developer#projects=&lt;/tt&gt;</td></tr><tr><td id="L1739" class="nb">1739</td><td>        # * &lt;tt&gt;Developer#project_ids&lt;/tt&gt;</td></tr><tr><td id="L1740" class="nb">1740</td><td>        # * &lt;tt&gt;Developer#project_ids=&lt;/tt&gt;</td></tr><tr><td id="L1741" class="nb">1741</td><td>        # * &lt;tt&gt;Developer#projects.clear&lt;/tt&gt;</td></tr><tr><td id="L1742" class="nb">1742</td><td>        # * &lt;tt&gt;Developer#projects.empty?&lt;/tt&gt;</td></tr><tr><td id="L1743" class="nb">1743</td><td>        # * &lt;tt&gt;Developer#projects.size&lt;/tt&gt;</td></tr><tr><td id="L1744" class="nb">1744</td><td>        # * &lt;tt&gt;Developer#projects.find(id)&lt;/tt&gt;</td></tr><tr><td id="L1745" class="nb">1745</td><td>        # * &lt;tt&gt;Developer#projects.exists?(...)&lt;/tt&gt;</td></tr><tr><td id="L1746" class="nb">1746</td><td>        # * &lt;tt&gt;Developer#projects.build&lt;/tt&gt; (similar to &lt;tt&gt;Project.new("developer_id" =&gt; id)&lt;/tt&gt;)</td></tr><tr><td id="L1747" class="nb">1747</td><td>        # * &lt;tt&gt;Developer#projects.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Project.new("developer_id" =&gt; id); c.save; c&lt;/tt&gt;)</td></tr><tr><td id="L1748" class="nb">1748</td><td>        # * &lt;tt&gt;Developer#projects.reload&lt;/tt&gt;</td></tr><tr><td id="L1749" class="nb">1749</td><td>        # The declaration may include an +options+ hash to specialize the behavior of the association.</td></tr><tr><td id="L1750" class="nb">1750</td><td>        #</td></tr><tr><td id="L1751" class="nb">1751</td><td>        # === Scopes</td></tr><tr><td id="L1752" class="nb">1752</td><td>        #</td></tr><tr><td id="L1753" class="nb">1753</td><td>        # You can pass a second argument +scope+ as a callable (i.e. proc or</td></tr><tr><td id="L1754" class="nb">1754</td><td>        # lambda) to retrieve a specific set of records or customize the generated</td></tr><tr><td id="L1755" class="nb">1755</td><td>        # query when you access the associated collection.</td></tr><tr><td id="L1756" class="nb">1756</td><td>        #</td></tr><tr><td id="L1757" class="nb">1757</td><td>        # Scope examples:</td></tr><tr><td id="L1758" class="nb">1758</td><td>        #   has_and_belongs_to_many :projects, -&gt; { includes(:milestones, :manager) }</td></tr><tr><td id="L1759" class="nb">1759</td><td>        #   has_and_belongs_to_many :categories, -&gt;(post) {</td></tr><tr><td id="L1760" class="nb">1760</td><td>        #     where("default_category = ?", post.default_category)</td></tr><tr><td id="L1761" class="nb">1761</td><td>        #</td></tr><tr><td id="L1762" class="nb">1762</td><td>        # === Extensions</td></tr><tr><td id="L1763" class="nb">1763</td><td>        #</td></tr><tr><td id="L1764" class="nb">1764</td><td>        # The +extension+ argument allows you to pass a block into a</td></tr><tr><td id="L1765" class="nb">1765</td><td>        # has_and_belongs_to_many association. This is useful for adding new</td></tr><tr><td id="L1766" class="nb">1766</td><td>        # finders, creators and other factory-type methods to be used as part of</td></tr><tr><td id="L1767" class="nb">1767</td><td>        # the association.</td></tr><tr><td id="L1768" class="nb">1768</td><td>        #</td></tr><tr><td id="L1769" class="nb">1769</td><td>        # Extension examples:</td></tr><tr><td id="L1770" class="nb">1770</td><td>        #   has_and_belongs_to_many :contractors do</td></tr><tr><td id="L1771" class="nb">1771</td><td>        #     def find_or_create_by_name(name)</td></tr><tr><td id="L1772" class="nb">1772</td><td>        #       first_name, last_name = name.split(" ", 2)</td></tr><tr><td id="L1773" class="nb">1773</td><td>        #       find_or_create_by(first_name: first_name, last_name: last_name)</td></tr><tr><td id="L1774" class="nb">1774</td><td>        #     end</td></tr><tr><td id="L1775" class="nb">1775</td><td>        #   end</td></tr><tr><td id="L1776" class="nb">1776</td><td>        #</td></tr><tr><td id="L1777" class="nb">1777</td><td>        # === Options</td></tr><tr><td id="L1778" class="nb">1778</td><td>        #</td></tr><tr><td id="L1779" class="nb">1779</td><td>        # [:class_name]</td></tr><tr><td id="L1780" class="nb">1780</td><td>        #   Specify the class name of the association. Use it only if that name can't be inferred</td></tr><tr><td id="L1781" class="nb">1781</td><td>        #   from the association name. So &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt; will by default be linked to the</td></tr><tr><td id="L1782" class="nb">1782</td><td>        #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.</td></tr><tr><td id="L1783" class="nb">1783</td><td>        # [:join_table]</td></tr><tr><td id="L1784" class="nb">1784</td><td>        #   Specify the name of the join table if the default based on lexical order isn't what you want.</td></tr><tr><td id="L1785" class="nb">1785</td><td>        #   &lt;b&gt;WARNING:&lt;/b&gt; If you're overwriting the table name of either class, the +table_name+ method</td></tr><tr><td id="L1786" class="nb">1786</td><td>        #   MUST be declared underneath any #has_and_belongs_to_many declaration in order to work.</td></tr><tr><td id="L1787" class="nb">1787</td><td>        # [:foreign_key]</td></tr><tr><td id="L1788" class="nb">1788</td><td>        #   Specify the foreign key used for the association. By default this is guessed to be the name</td></tr><tr><td id="L1789" class="nb">1789</td><td>        #   of this class in lower-case and "_id" suffixed. So a Person class that makes</td></tr><tr><td id="L1790" class="nb">1790</td><td>        #   a #has_and_belongs_to_many association to Project will use "person_id" as the</td></tr><tr><td id="L1791" class="nb">1791</td><td>        #   default &lt;tt&gt;:foreign_key&lt;/tt&gt;.</td></tr><tr><td id="L1792" class="nb">1792</td><td>        # [:association_foreign_key]</td></tr><tr><td id="L1793" class="nb">1793</td><td>        #   Specify the foreign key used for the association on the receiving side of the association.</td></tr><tr><td id="L1794" class="nb">1794</td><td>        #   By default this is guessed to be the name of the associated class in lower-case and "_id" suffixed.</td></tr><tr><td id="L1795" class="nb">1795</td><td>        #   So if a Person class makes a #has_and_belongs_to_many association to Project,</td></tr><tr><td id="L1796" class="nb">1796</td><td>        #   the association will use "project_id" as the default &lt;tt&gt;:association_foreign_key&lt;/tt&gt;.</td></tr><tr><td id="L1797" class="nb">1797</td><td>        # [:validate]</td></tr><tr><td id="L1798" class="nb">1798</td><td>        #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.</td></tr><tr><td id="L1799" class="nb">1799</td><td>        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.</td></tr><tr><td id="L1800" class="nb">1800</td><td>        # [:autosave]</td></tr><tr><td id="L1801" class="nb">1801</td><td>        #   If true, always save the associated objects or destroy them if marked for destruction, when</td></tr><tr><td id="L1802" class="nb">1802</td><td>        #   saving the parent object.</td></tr><tr><td id="L1803" class="nb">1803</td><td>        #   If false, never save or destroy the associated objects.</td></tr><tr><td id="L1804" class="nb">1804</td><td>        #   By default, only save associated objects that are new records.</td></tr><tr><td id="L1805" class="nb">1805</td><td>        #</td></tr><tr><td id="L1806" class="nb">1806</td><td>        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets</td></tr><tr><td id="L1807" class="nb">1807</td><td>        #   &lt;tt&gt;:autosave&lt;/tt&gt; to &lt;tt&gt;true&lt;/tt&gt;.</td></tr><tr><td id="L1808" class="nb">1808</td><td>        #</td></tr><tr><td id="L1809" class="nb">1809</td><td>        # Option examples:</td></tr><tr><td id="L1810" class="nb">1810</td><td>        #   has_and_belongs_to_many :projects</td></tr><tr><td id="L1811" class="nb">1811</td><td>        #   has_and_belongs_to_many :projects, -&gt; { includes(:milestones, :manager) }</td></tr><tr><td id="L1812" class="nb">1812</td><td>        #   has_and_belongs_to_many :nations, class_name: "Country"</td></tr><tr><td id="L1813" class="nb">1813</td><td>        #   has_and_belongs_to_many :categories, join_table: "prods_cats"</td></tr><tr><td id="L1814" class="nb">1814</td><td>        #   has_and_belongs_to_many :categories, -&gt; { readonly }</td></tr><tr><td id="L1815" class="nb">1815</td><td>        <span class="node-def kind-keyword run" title="11x">def</span> <span class="node-def kind-name run" title="11x">has_and_belongs_to_many</span>(name, scope = <span class="node-nil kind-expression run" title="549x">nil</span>, **options, &amp;extension)</td></tr><tr><td id="L1816" class="nb">1816</td><td>          <span class="node-lvasgn kind-name run" title="813x">habtm_reflection</span> <span class="node-lvasgn kind-operator run" title="813x">=</span> <span class="node-const kind-name run" title="813x">ActiveRecord</span><span class="node-const kind-double_colon run" title="813x">::</span><span class="node-const kind-name run" title="813x">Reflection</span><span class="node-const kind-double_colon run" title="813x">::</span><span class="node-const kind-name run" title="813x">HasAndBelongsToManyReflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">new</span>(<span class="node-lvar kind-name run" title="813x">name</span>, <span class="node-lvar kind-name run" title="813x">scope</span>, <span class="node-lvar kind-name run" title="813x">options</span>, <span class="node-self kind-expression run" title="813x">self</span>)</td></tr><tr><td id="L1817" class="nb">1817</td><td></td></tr><tr><td id="L1818" class="nb">1818</td><td>          <span class="node-lvasgn kind-name run" title="813x">builder</span> <span class="node-lvasgn kind-operator run" title="813x">=</span> <span class="node-const kind-name run" title="813x">Builder</span><span class="node-const kind-double_colon run" title="813x">::</span><span class="node-const kind-name run" title="813x">HasAndBelongsToMany</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">new</span> <span class="node-lvar kind-name run" title="813x">name</span>, <span class="node-self kind-expression run" title="813x">self</span>, <span class="node-lvar kind-name run" title="813x">options</span></td></tr><tr><td id="L1819" class="nb">1819</td><td></td></tr><tr><td id="L1820" class="nb">1820</td><td>          <span class="node-lvasgn kind-name run" title="813x">join_model</span> <span class="node-lvasgn kind-operator run" title="813x">=</span> <span class="node-lvar kind-name run" title="813x">builder</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">through_model</span></td></tr><tr><td id="L1821" class="nb">1821</td><td></td></tr><tr><td id="L1822" class="nb">1822</td><td>          <span class="node-send kind-selector_begin run" title="813x">const_set</span> <span class="node-lvar kind-name run" title="813x">join_model</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">name</span>, <span class="node-lvar kind-name run" title="813x">join_model</span></td></tr><tr><td id="L1823" class="nb">1823</td><td>          <span class="node-send kind-selector_begin run" title="813x">private_constant</span> <span class="node-lvar kind-name run" title="813x">join_model</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">name</span></td></tr><tr><td id="L1824" class="nb">1824</td><td></td></tr><tr><td id="L1825" class="nb">1825</td><td>          <span class="node-lvasgn kind-name run" title="813x">middle_reflection</span> <span class="node-lvasgn kind-operator run" title="813x">=</span> <span class="node-lvar kind-name run" title="813x">builder</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">middle_reflection</span> <span class="node-lvar kind-name run" title="813x">join_model</span></td></tr><tr><td id="L1826" class="nb">1826</td><td></td></tr><tr><td id="L1827" class="nb">1827</td><td>          <span class="node-const kind-name run" title="813x">Builder</span><span class="node-const kind-double_colon run" title="813x">::</span><span class="node-const kind-name run" title="813x">HasMany</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">define_callbacks</span> <span class="node-self kind-expression run" title="813x">self</span>, <span class="node-lvar kind-name run" title="813x">middle_reflection</span></td></tr><tr><td id="L1828" class="nb">1828</td><td>          <span class="node-const kind-name run" title="813x">Reflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">add_reflection</span> <span class="node-self kind-expression run" title="813x">self</span>, <span class="node-lvar kind-name run" title="813x">middle_reflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">name</span>, <span class="node-lvar kind-name run" title="813x">middle_reflection</span></td></tr><tr><td id="L1829" class="nb">1829</td><td>          <span class="node-lvar kind-name run" title="813x">middle_reflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">parent_reflection</span> <span class="node-send kind-operator run" title="813x">=</span> <span class="node-lvar kind-name run" title="813x">habtm_reflection</span></td></tr><tr><td id="L1830" class="nb">1830</td><td></td></tr><tr><td id="L1831" class="nb">1831</td><td>          <span class="node-send kind-selector_begin run" title="813x">include</span> <span class="node-const kind-name run" title="813x">Module</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">new</span> {</td></tr><tr><td id="L1832" class="nb">1832</td><td>            <span class="node-send kind-selector_begin run" title="813x">class_eval</span> <span class="node-dstr kind-expression run" title="813x">&lt;&lt;-RUBY</span>, <span class="node-str kind-expression run" title="813x">__FILE__</span>, <span class="node-int kind-expression run" title="813x">__LINE__</span> <span class="node-send kind-selector_begin run" title="813x">+</span> <span class="node-int kind-expression run" title="813x">1</span></td></tr><tr><td id="L1833" class="nb">1833</td><td><span class="node-str kind-expression run" title="813x">              def destroy_associations</span></td></tr><tr><td id="L1834" class="nb">1834</td><td><span class="node-str kind-expression run" title="813x">                association(:</span><span class="node-begin kind-begin run" title="813x">#{</span><span class="node-lvar kind-name run" title="813x">middle_reflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">name</span><span class="node-begin kind-end run" title="813x">}</span><span class="node-str kind-expression run" title="813x">).delete_all(:delete_all)</span></td></tr><tr><td id="L1835" class="nb">1835</td><td><span class="node-str kind-expression run" title="813x">                association(:</span><span class="node-begin kind-begin run" title="813x">#{</span><span class="node-lvar kind-name run" title="813x">name</span><span class="node-begin kind-end run" title="813x">}</span><span class="node-str kind-expression run" title="813x">).reset</span></td></tr><tr><td id="L1836" class="nb">1836</td><td><span class="node-str kind-expression run" title="813x">                super</span></td></tr><tr><td id="L1837" class="nb">1837</td><td><span class="node-str kind-expression run" title="813x">              end</span></td></tr><tr><td id="L1838" class="nb">1838</td><td><span class="node-dstr kind-heredoc_end run" title="813x">            RUBY</span></td></tr><tr><td id="L1839" class="nb">1839</td><td>          }</td></tr><tr><td id="L1840" class="nb">1840</td><td></td></tr><tr><td id="L1841" class="nb">1841</td><td>          <span class="node-lvasgn kind-name run" title="813x">hm_options</span> <span class="node-lvasgn kind-operator run" title="813x">=</span> <span class="node-hash kind-begin run" title="813x">{</span><span class="node-hash kind-end run" title="813x">}</span></td></tr><tr><td id="L1842" class="nb">1842</td><td>          <span class="node-lvar kind-name run" title="813x">hm_options</span><span class="node-send kind-selector_begin run" title="813x">[</span><span class="node-sym kind-expression run" title="813x">:through</span><span class="node-send kind-selector_end run" title="813x">]</span> <span class="node-send kind-operator run" title="813x">=</span> <span class="node-lvar kind-name run" title="813x">middle_reflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">name</span></td></tr><tr><td id="L1843" class="nb">1843</td><td>          <span class="node-lvar kind-name run" title="813x">hm_options</span><span class="node-send kind-selector_begin run" title="813x">[</span><span class="node-sym kind-expression run" title="813x">:source</span><span class="node-send kind-selector_end run" title="813x">]</span> <span class="node-send kind-operator run" title="813x">=</span> <span class="node-lvar kind-name run" title="813x">join_model</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">right_reflection</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">name</span></td></tr><tr><td id="L1844" class="nb">1844</td><td></td></tr><tr><td id="L1845" class="nb">1845</td><td>          <span class="node-array kind-begin run" title="813x">[</span><span class="node-sym kind-expression run" title="813x">:before_add</span>, <span class="node-sym kind-expression run" title="813x">:after_add</span>, <span class="node-sym kind-expression run" title="813x">:before_remove</span>, <span class="node-sym kind-expression run" title="813x">:after_remove</span>, <span class="node-sym kind-expression run" title="813x">:autosave</span>, <span class="node-sym kind-expression run" title="813x">:validate</span>, <span class="node-sym kind-expression run" title="813x">:join_table</span>, <span class="node-sym kind-expression run" title="813x">:class_name</span>, <span class="node-sym kind-expression run" title="813x">:extend</span><span class="node-array kind-end run" title="813x">]</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">each</span> do |k|</td></tr><tr><td id="L1846" class="nb">1846</td><td>            <span class="fork fork-whole fork-run " data-fork-id="32"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="7317x"></i><span class="fork fork-branch fork-run " data-fork-id="32"><i class="fork-icon fa fa-code-fork" aria-hidden="true" title="868x"></i><span class="node-lvar kind-name run" title="868x">hm_options</span><span class="node-send kind-selector_begin run" title="868x">[</span><span class="node-lvar kind-name run" title="868x">k</span><span class="node-send kind-selector_end run" title="868x">]</span> <span class="node-send kind-operator run" title="868x">=</span> <span class="node-lvar kind-name run" title="868x">options</span><span class="node-send kind-selector_begin run" title="868x">[</span><span class="node-lvar kind-name run" title="868x">k</span><span class="node-send kind-selector_end run" title="868x">]</span></span> <span class="node-if kind-keyword run" title="7317x">if</span> <span class="node-lvar kind-name run" title="7317x">options</span><span class="node-send kind-dot run" title="7317x">.</span><span class="node-send kind-selector_begin run" title="7317x">key?</span> <span class="node-lvar kind-name run" title="7317x">k</span></span></td></tr><tr><td id="L1847" class="nb">1847</td><td>          end</td></tr><tr><td id="L1848" class="nb">1848</td><td></td></tr><tr><td id="L1849" class="nb">1849</td><td>          <span class="node-send kind-selector_begin run" title="813x">has_many</span> <span class="node-lvar kind-name run" title="813x">name</span>, <span class="node-lvar kind-name run" title="813x">scope</span>, <span class="node-lvar kind-name run" title="813x">hm_options</span>, <span class="node-block_pass kind-operator run" title="813x">&amp;</span><span class="node-lvar kind-name run" title="813x">extension</span></td></tr><tr><td id="L1850" class="nb">1850</td><td>          <span class="node-send kind-selector_begin run" title="813x">_reflections</span><span class="node-send kind-selector_begin run" title="813x">[</span><span class="node-lvar kind-name run" title="813x">name</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">to_s</span><span class="node-send kind-selector_end run" title="813x">]</span><span class="node-send kind-dot run" title="813x">.</span><span class="node-send kind-selector_begin run" title="813x">parent_reflection</span> <span class="node-send kind-operator run" title="813x">=</span> <span class="node-lvar kind-name run" title="813x">habtm_reflection</span></td></tr><tr><td id="L1851" class="nb">1851</td><td>        end</td></tr><tr><td id="L1852" class="nb">1852</td><td>      end</td></tr><tr><td id="L1853" class="nb">1853</td><td>  end</td></tr><tr><td id="L1854" class="nb">1854</td><td>end</td></tr></table></main>
    <script>
      $(function() {
        $('.stats .branch').click(function() {
          $('body').toggleClass('show-forks')
        });
      });
    </script>
  </body>
</html>
